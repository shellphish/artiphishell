#! /usr/bin/env uv
# /// script
# requires-python = "==3.12"
# dependencies = [
#     "agentlib",
#     "pyyaml",
# ]
#
# [tool.uv.sources]
# agentlib = { path = "../../../libs/agentlib" }
# ///

#! /usr/bin/env python3
import os
import argparse

os.chdir(os.path.dirname(__file__))

from agentlib import CodeExtractor, AgentWithHistory, Code
from agentlib.lib.common.logger import StaticLogger
from agentlib.lib.common.parsers import CodeCutoffException, NoCodeFoundException
from collections import OrderedDict
from pathlib import Path

from yaml import safe_load, safe_dump

CRS_ROOT = Path(os.path.dirname(__file__)) / "../../.."
MODEL_OUT_PATH = (
    CRS_ROOT / "libs/crs-utils/src/shellphish_crs_utils/models/aixcc_api.py"
)
API_OUT_PATH = CRS_ROOT / "libs/crs-api/crs_api/crs_api_endpoints.py"
COMPETITION_API_OUT_PATH = CRS_ROOT / "libs/crs-api/competition_api.py"
EXAMPLE_REPO_PATH = CRS_ROOT / "aixcc-infra/afc-api-schema/example-crs-architecture"
API_DOCS_PATH = EXAMPLE_REPO_PATH / "docs/api"
COMPETITION_SERVER_OUT_PATH = (
    CRS_ROOT / "aixcc-infra/aixcc-afc-competition-api/src/server.py"
)
SARIF_MODEL_OUT_PATH = (
    CRS_ROOT / "libs/crs-utils/src/shellphish_crs_utils/models/sarif.py"
)


class SwaggerSchemaAgent(AgentWithHistory[dict, str]):
    __LLM_MODEL__ = "claude-3-7-sonnet"
    __SYSTEM_PROMPT_TEMPLATE__ = "schema.system.j2"
    __USER_PROMPT_TEMPLATE__ = "schema.user.j2"

    __OUTPUT_PARSER__ = CodeExtractor(language="python")

    __LLM_ARGS__ = {
        "temperature": 0.0,
    }

    output_path: Path
    schema_files: list[Path] = []

    def get_input_vars(self, *args, **kw):
        existing_path = self.output_path
        existing = ""
        if existing_path.exists():
            with open(existing_path, "r") as f:
                existing = f.read()

        if (
            existing.strip().startswith("#")
            and "AUTOGENERATED" in existing
            and "\n\n" in existing
        ):
            existing = existing.split("\n\n", 1)[1]

        schema_files = OrderedDict()
        for schema_file in self.schema_files:
            with open(schema_file, "r") as f:
                data = safe_load(f)
                definitions = data["definitions"]
                props = data.get("properties", {})

                out = OrderedDict()
                if props:
                    out["properties"] = props
                if definitions:
                    out["definitions"] = definitions

                schema_files[schema_file.stem] = safe_dump(dict(out))

        vars = super().get_input_vars(*args, **kw)
        vars.update(
            existing=existing,
            schema_files=schema_files,
        )
        return vars


class SwaggerApiAgent(AgentWithHistory[dict, str]):
    __LLM_MODEL__ = "claude-3-7-sonnet"
    __SYSTEM_PROMPT_TEMPLATE__ = "api.system.j2"
    __USER_PROMPT_TEMPLATE__ = "api.user.j2"

    __OUTPUT_PARSER__ = CodeExtractor(language="python")

    __LLM_ARGS__ = {
        "temperature": 0.0,
    }

    def get_input_vars(self, *args, **kw):
        existing_path = API_OUT_PATH
        existing = ""
        if existing_path.exists():
            with open(existing_path, "r") as f:
                existing = f.read()

        if (
            existing.strip().startswith("#")
            and "AUTOGENERATED" in existing
            and "\n\n" in existing
        ):
            existing = existing.split("\n\n", 1)[1]

        tasking_api_schema_path = API_DOCS_PATH / "crs-swagger.yaml"

        with open(tasking_api_schema_path, "r") as f:
            tasking_api_schema = safe_load(f)["paths"]

        api_models_path = MODEL_OUT_PATH
        with open(api_models_path, "r") as f:
            api_models = f.read()

        impl_base_class_path = (
            CRS_ROOT / "libs/crs-api/crs_api/crs_api_base.py"
        )
        with open(impl_base_class_path, "r") as f:
            impl_base_class = f.read()

        vars = super().get_input_vars(*args, **kw)
        vars.update(
            existing=existing,
            tasking_api_schema=safe_dump(tasking_api_schema),
            api_models=api_models,
            impl_base_class=impl_base_class,
        )
        return vars


class SwaggerCompetitionApiAgent(AgentWithHistory[dict, str]):
    __LLM_MODEL__ = "claude-3-7-sonnet"
    __SYSTEM_PROMPT_TEMPLATE__ = "competition_api.system.j2"
    __USER_PROMPT_TEMPLATE__ = "competition_api.user.j2"

    __OUTPUT_PARSER__ = CodeExtractor(language="python")

    __LLM_ARGS__ = {
        "temperature": 0.0,
    }

    def get_input_vars(self, *args, **kw):
        existing_path = COMPETITION_API_OUT_PATH
        existing = ""
        if existing_path.exists():
            with open(existing_path, "r") as f:
                existing = f.read()

        if (
            existing.strip().startswith("#")
            and "AUTOGENERATED" in existing
            and "\n\n" in existing
        ):
            existing = existing.split("\n\n", 1)[1]

        competition_api_schema_path = API_DOCS_PATH / "competition-swagger.json"

        with open(competition_api_schema_path, "r") as f:
            competition_api_schema = safe_load(f)["paths"]

        api_models_path = MODEL_OUT_PATH
        with open(api_models_path, "r") as f:
            api_models = f.read()

        vars = super().get_input_vars(*args, **kw)
        vars.update(
            existing=existing,
            competition_api_schema=safe_dump(competition_api_schema),
            api_models=api_models,
        )
        return vars


class CodeContinueAgent(AgentWithHistory[dict, Code]):
    def __init__(
        self,
        target_agent: AgentWithHistory[dict, Code],
        had_previous_code: bool = True,
        **kw,
    ):
        # We need to pass output_path explicitly since it's required by SwaggerSchemaAgent
        if hasattr(target_agent, "output_path") and "output_path" not in kw:
            kw["output_path"] = target_agent.output_path

        # Pass chat_history from the target agent
        kw["chat_history"] = target_agent.chat_history

        # Initialize the parent class
        super().__init__(**kw)

        # Set the target agent
        self.target_agent = target_agent
        self.had_previous_code = had_previous_code

    def __getattribute__(self, name):
        StaticLogger.warn_static("================" + name)
        # These attributes should be handled by this class
        if name in (
            "get_user_prompt",
            "invoke",
            "invoke_agent",
            "get_single_agent_response",
            "create_langchain_agent",
            "get_simple_response_executor",
            "create_langchain_agent",
            "target_agent",
            "had_previous_code",
            "__class__",
            "__dict__",
        ):
            return object.__getattribute__(self, name)

        # For all other attributes, delegate to the target agent
        try:
            target = object.__getattribute__(self, "target_agent")
            return getattr(target, name)
        except AttributeError:
            # Fall back to this object's attributes if target_agent doesn't have it
            return object.__getattribute__(self, name)

    def get_user_prompt(self):
        if not self.had_previous_code:
            return self.load_prompt(
                """
In the previous message you did not get to produce any code.
                                    
Please write the code now.
""",
                role="user",
            )

        return self.load_prompt(
            """
The code got cut off. Please just directly continue where it stopped (do not repeat anything from the previous code as this will just be concated to the end of the previous code). You must start with triple backquotes ``` and finish with tripple backquotes ```.

For example if the previous code was:
```
def hello_world(my_a
------ CUT OFF HERE ------
Then you would start with:
```
rgument):
    return f'Hello ' + my_argument
```
""",
            role="user",
        )


class SwaggerCompetitionServerAgent(AgentWithHistory[dict, str]):
    __LLM_MODEL__ = "claude-3-7-sonnet"
    __SYSTEM_PROMPT_TEMPLATE__ = "competition_server.system.j2"
    __USER_PROMPT_TEMPLATE__ = "competition_server.user.j2"

    __OUTPUT_PARSER__ = CodeExtractor(language="python")

    __LLM_ARGS__ = {
        "temperature": 0.0,
    }

    def get_input_vars(self, *args, **kw):
        existing_path = COMPETITION_SERVER_OUT_PATH
        existing = ""
        if existing_path.exists():
            with open(existing_path, "r") as f:
                existing = f.read()

        if (
            existing.strip().startswith("#")
            and "AUTOGENERATED" in existing
            and "\n\n" in existing
        ):
            existing = existing.split("\n\n", 1)[1]

        competition_api_schema_path = API_DOCS_PATH / "competition-swagger.json"

        with open(competition_api_schema_path, "r") as f:
            competition_api_schema = safe_load(f)

        api_models_path = MODEL_OUT_PATH
        with open(api_models_path, "r") as f:
            api_models = f.read()

        impl_base_class_path = COMPETITION_SERVER_OUT_PATH.parent / "server_base.py"
        with open(impl_base_class_path, "r") as f:
            impl_base_class = f.read()

        vars = super().get_input_vars(*args, **kw)
        vars.update(
            existing=existing,
            competition_api_schema=safe_dump(competition_api_schema),
            api_models=api_models,
            impl_base_class=impl_base_class,
        )
        return vars


def get_existing_api_schema_commit_hash():
    if not API_OUT_PATH.exists():
        return None
    with open(API_OUT_PATH, "r") as f:
        source = f.read()
        try:
            sha_hash = source.split("#")[1].split("\n")[0].strip()
            return sha_hash
        except Exception as e:
            print(f"Error getting existing API schema commit hash: {e}")
            return None


def get_all_code(agent: AgentWithHistory[dict, Code], **input):
    source_code = ""
    is_original_agent = True
    has_code = False
    for i in range(6):
        print("Generating code...")
        res = agent.invoke(input)
        if res.value:
            source_code += res.value.source_code.strip()
            has_code = True
            break

        StaticLogger.warn_static(f"Failed to generate code: {type(res.error_raw)}")

        if isinstance(res.error_raw, CodeCutoffException):
            StaticLogger.warn_static("Code was cutoff before closing backticks")
            rs = res.error_raw.source_code
            source_code += rs.lstrip()
            has_code = True
        elif isinstance(res.error_raw, NoCodeFoundException):
            StaticLogger.warn_static("No code was found")
        else:
            raise res.error_raw

        if is_original_agent:
            agent = CodeContinueAgent(agent, had_previous_code=has_code)
            is_original_agent = False

    return source_code


def update_model_schema(sha_hash, instructions=""):
    agent = SwaggerSchemaAgent(
        output_path=MODEL_OUT_PATH,
        schema_files=[
            API_DOCS_PATH / "crs-swagger.yaml",
            API_DOCS_PATH / "competition-swagger.yaml",
        ],
    )

    agent.use_web_logging_config(clear=True)

    source = get_all_code(agent, instructions=instructions)
    print(source)

    api_source_path = MODEL_OUT_PATH

    source = f"# {sha_hash}\n# AUTOGENERATED BY afc-api-schema, but you can change the descriptions if you like\n\n{source}\n"

    with open(api_source_path, "w") as f:
        f.write(source)


def update_sarif_model(sha_hash, instructions=""):
    agent = SwaggerSchemaAgent(
        output_path=SARIF_MODEL_OUT_PATH,
        schema_files=[
            API_DOCS_PATH / "sarif-schema.json",
        ],
    )
    agent.use_web_logging_config(clear=True)
    res = get_all_code(agent, instructions=instructions)
    print(res)

    sarif_source_path = SARIF_MODEL_OUT_PATH

    source = res
    source = f"# {sha_hash}\n# AUTOGENERATED BY afc-api-schema, but you can change the descriptions if you like\n\n{source}\n"

    with open(sarif_source_path, "w") as f:
        f.write(source)


def update_api_schema(sha_hash, instructions=""):
    agent = SwaggerApiAgent()
    agent.use_web_logging_config(clear=True)
    res = get_all_code(agent, instructions=instructions)
    print(res)

    api_source_path = API_OUT_PATH

    server_start = (
        "def start_server():\n    app.run()"  # Called to start the flask server
    )

    source = res
    source = f"# {sha_hash}\n# AUTOGENERATED BY afc-api-schema, but you can change the descriptions if you like\n\n{source}\n\n{server_start if 'server_start' not in source else ''}"

    with open(api_source_path, "w") as f:
        f.write(source)


def update_competition_api_schema(sha_hash, instructions=""):
    agent = SwaggerCompetitionApiAgent()
    agent.use_web_logging_config(clear=True)
    res = get_all_code(agent, instructions=instructions)
    print(res)

    api_source_path = COMPETITION_API_OUT_PATH
    source = res
    source = f"# {sha_hash}\n# AUTOGENERATED BY afc-api-schema\n\n{source}\n"

    with open(api_source_path, "w") as f:
        f.write(source)


def update_competition_api_server(sha_hash, instructions=""):
    agent = SwaggerCompetitionServerAgent()
    agent.use_web_logging_config(clear=True)
    res = get_all_code(agent, instructions=instructions)
    print(res)

    api_source_path = COMPETITION_SERVER_OUT_PATH
    source = res
    source = f"# {sha_hash}\n# AUTOGENERATED BY afc-api-schema\n\n{source}\n"

    with open(api_source_path, "w") as f:
        f.write(source)


UPSTREAM_SOURCE_REPO = "https://github.com/aixcc-finals/example-crs-architecture.git"

from git import Repo


def update_upstream_api_source(force=False, instructions=""):
    api_source_path = EXAMPLE_REPO_PATH
    api_source_path = api_source_path.absolute()

    # This is a git repo which may not exist yet
    if not api_source_path.exists():
        Repo.clone_from(UPSTREAM_SOURCE_REPO, api_source_path)

    assert api_source_path.exists()

    repo = Repo(api_source_path)

    existing_sha_hash = get_existing_api_schema_commit_hash()
    print(f"Docs were last generated from commit: {existing_sha_hash}")
    repo.git.checkout(existing_sha_hash)
    print("Pulling from upstream...")
    repo.remotes.origin.pull("main")

    # Get the last commit that modified the docs/api directory
    new_sha_hash = [commit.hexsha for commit in repo.iter_commits(paths="docs/api")][0]
    print(f"Newest commit that modified docs/api: {new_sha_hash}")

    # Check if the current sha hash is the same as the existing sha hash
    docs_updated = new_sha_hash != existing_sha_hash

    if not MODEL_OUT_PATH.exists():
        docs_updated = True
    if not API_OUT_PATH.exists():
        docs_updated = True

    if docs_updated:
        print("Docs directory was updated")
    else:
        print("Docs directory was not updated")

    if docs_updated or force:
        update_model_schema(new_sha_hash, instructions=instructions)
        # update_sarif_model(new_sha_hash, instructions=instructions)
        update_api_schema(new_sha_hash, instructions=instructions)
        update_competition_api_schema(new_sha_hash, instructions=instructions)
        update_competition_api_server(new_sha_hash, instructions=instructions)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--force", action="store_true", help="Force update the API schema"
    )
    parser.add_argument(
        "--instructions",
        type=str,
        help="Additional instructions for the AI",
        default="",
        required=False,
    )
    args = parser.parse_args()
    update_upstream_api_source(args.force, args.instructions)
