######################################################################
# Helper Functions
######################################################################

def artiphishell_base64_encode(data: bytes) -> bytes:
    import base64
    return base64.b64encode(data)

def utf8_encode(STRING: bytes) -> bytes:
    try:
        s = STRING.decode('ascii')
        encoded = s.encode('utf-8')
        length = len(encoded).to_bytes(2, 'big')
        return length + encoded
    except:
        return b'\x00\x06default'

######################################################################
# Grammar Rules
######################################################################

ctx.rule('START', b'{MAGIC}{VERSION}{CONSTANT_POOL}{ACCESS_FLAGS}{THIS_CLASS}{SUPER_CLASS}{INTERFACES}{FIELDS}{METHODS}{ATTRIBUTES}')
ctx.literal('MAGIC', b'\xca\xfe\xba\xbe')
ctx.rule('VERSION', b'{MINOR}{MAJOR}')
ctx.bytes('MINOR', 2)
ctx.literal('MAJOR', b'\x003')
ctx.literal('MAJOR', b'\x004')
ctx.literal('MAJOR', b'\x005')
ctx.literal('MAJOR', b'\x006')
ctx.rule('CONSTANT_POOL', b'{CP_COUNT}{CP_ENTRIES}')
ctx.literal('CP_COUNT', b'\x00 ')
ctx.rule('CP_ENTRIES', b'{CP_ENTRY}{CP_ENTRIES}')
ctx.literal('CP_ENTRIES', b'')
ctx.rule('CP_ENTRY', b'{CP_UTF8}')
ctx.rule('CP_ENTRY', b'{CP_INTEGER}')
ctx.rule('CP_ENTRY', b'{CP_FLOAT}')
ctx.rule('CP_ENTRY', b'{CP_STRING}')
ctx.rule('CP_ENTRY', b'{CP_CLASS}')
ctx.rule('CP_ENTRY', b'{CP_METHODREF}')
ctx.rule('CP_ENTRY', b'{CP_FIELDREF}')
ctx.rule('CP_ENTRY', b'{CP_NAME_TYPE}')
ctx.rule('CP_UTF8', b'\x01{UTF8_CONTENT}')
ctx.script('UTF8_CONTENT', ['STRING_CONTENT'], utf8_encode)
ctx.regex('STRING_CONTENT', '(Test|Main|Object|String|Integer|List)')
ctx.regex('STRING_CONTENT', '[A-Za-z_$][A-Za-z0-9_$]{0,32}')
ctx.regex('STRING_CONTENT', 'java/lang/[A-Za-z]+')
ctx.regex('STRING_CONTENT', '(main|init|run|execute|process|handle)')
ctx.regex('STRING_CONTENT', '\\(\\)V')
ctx.regex('STRING_CONTENT', '\\(Ljava/lang/String;\\)V')
ctx.regex('STRING_CONTENT', '\\(I\\)V')
ctx.regex('STRING_CONTENT', 'Code')
ctx.regex('STRING_CONTENT', 'LineNumberTable')
ctx.regex('STRING_CONTENT', 'SourceFile')
ctx.rule('CP_INTEGER', b'\x03{INT_VALUE}')
ctx.bytes('INT_VALUE', 4)
ctx.rule('CP_FLOAT', b'\x04{FLOAT_VALUE}')
ctx.bytes('FLOAT_VALUE', 4)
ctx.rule('CP_STRING', b'\x08{STRING_INDEX}')
ctx.bytes('STRING_INDEX', 2)
ctx.rule('CP_CLASS', b'\x07{CLASS_NAME_INDEX}')
ctx.bytes('CLASS_NAME_INDEX', 2)
ctx.rule('CP_METHODREF', b'\n{METHOD_CLASS_INDEX}{METHOD_NT_INDEX}')
ctx.bytes('METHOD_CLASS_INDEX', 2)
ctx.bytes('METHOD_NT_INDEX', 2)
ctx.rule('CP_FIELDREF', b'\t{FIELD_CLASS_INDEX}{FIELD_NT_INDEX}')
ctx.bytes('FIELD_CLASS_INDEX', 2)
ctx.bytes('FIELD_NT_INDEX', 2)
ctx.rule('CP_NAME_TYPE', b'\x0c{NAME_INDEX}{TYPE_INDEX}')
ctx.bytes('NAME_INDEX', 2)
ctx.bytes('TYPE_INDEX', 2)
ctx.literal('ACCESS_FLAGS', b'\x00!')
ctx.literal('ACCESS_FLAGS', b'\x00\x01')
ctx.literal('ACCESS_FLAGS', b'\x001')
ctx.literal('ACCESS_FLAGS', b'\x04\x00')
ctx.literal('ACCESS_FLAGS', b'\x04 ')
ctx.literal('ACCESS_FLAGS', b'\x00A')
ctx.bytes('THIS_CLASS', 2)
ctx.bytes('SUPER_CLASS', 2)
ctx.rule('INTERFACES', b'{INTERFACE_COUNT}{INTERFACE_LIST}')
ctx.bytes('INTERFACE_COUNT', 2)
ctx.rule('INTERFACE_LIST', b'{INTERFACE_INDEX}{INTERFACE_LIST}')
ctx.literal('INTERFACE_LIST', b'')
ctx.bytes('INTERFACE_INDEX', 2)
ctx.rule('FIELDS', b'{FIELD_COUNT}{FIELD_LIST}')
ctx.bytes('FIELD_COUNT', 2)
ctx.rule('FIELD_LIST', b'{FIELD_INFO}{FIELD_LIST}')
ctx.literal('FIELD_LIST', b'')
ctx.rule('FIELD_INFO', b'{FIELD_ACCESS}{FIELD_NAME}{FIELD_DESC}{FIELD_ATTRS}')
ctx.bytes('FIELD_ACCESS', 2)
ctx.bytes('FIELD_NAME', 2)
ctx.bytes('FIELD_DESC', 2)
ctx.rule('FIELD_ATTRS', b'{FIELD_ATTR_COUNT}{FIELD_ATTR_INFO}')
ctx.bytes('FIELD_ATTR_COUNT', 2)
ctx.rule('FIELD_ATTR_INFO', b'{CONST_VALUE_ATTR}')
ctx.literal('FIELD_ATTR_INFO', b'')
ctx.rule('CONST_VALUE_ATTR', b'{ATTR_NAME_INDEX}\x00\x00\x00\x02{CONST_INDEX}')
ctx.bytes('ATTR_NAME_INDEX', 2)
ctx.bytes('CONST_INDEX', 2)
ctx.rule('METHODS', b'{METHOD_COUNT}{METHOD_LIST}')
ctx.bytes('METHOD_COUNT', 2)
ctx.rule('METHOD_LIST', b'{METHOD_INFO}{METHOD_LIST}')
ctx.literal('METHOD_LIST', b'')
ctx.rule('METHOD_INFO', b'{METHOD_ACCESS}{METHOD_NAME}{METHOD_DESC}{METHOD_ATTRS}')
ctx.bytes('METHOD_ACCESS', 2)
ctx.bytes('METHOD_NAME', 2)
ctx.bytes('METHOD_DESC', 2)
ctx.rule('METHOD_ATTRS', b'{METHOD_ATTR_COUNT}{CODE_ATTR}')
ctx.bytes('METHOD_ATTR_COUNT', 2)
ctx.rule('CODE_ATTR', b'{CODE_NAME}{CODE_LENGTH}{CODE_CONTENT}')
ctx.bytes('CODE_NAME', 2)
ctx.bytes('CODE_LENGTH', 4)
ctx.rule('CODE_CONTENT', b'{MAX_STACK}{MAX_LOCALS}{CODE_SIZE}{BYTECODE}{EXCEPTIONS}{CODE_ATTRS}')
ctx.bytes('MAX_STACK', 2)
ctx.bytes('MAX_LOCALS', 2)
ctx.bytes('CODE_SIZE', 4)
ctx.rule('BYTECODE', b'{INSTRUCTION}{BYTECODE}')
ctx.literal('BYTECODE', b'')
ctx.literal('INSTRUCTION', b'*')
ctx.literal('INSTRUCTION', b'\xb1')
ctx.literal('INSTRUCTION', b'\xb7')
ctx.literal('INSTRUCTION', b'\xb2')
ctx.literal('INSTRUCTION', b'\xb6')
ctx.literal('INSTRUCTION', b'\x12')
ctx.literal('INSTRUCTION', b'\x10')
ctx.literal('INSTRUCTION', b'\x03')
ctx.literal('INSTRUCTION', b'\x04')
ctx.literal('INSTRUCTION', b'Y')
ctx.rule('EXCEPTIONS', b'{EXCEPTION_COUNT}{EXCEPTION_TABLE}')
ctx.bytes('EXCEPTION_COUNT', 2)
ctx.rule('EXCEPTION_TABLE', b'{EXCEPTION_ENTRY}{EXCEPTION_TABLE}')
ctx.literal('EXCEPTION_TABLE', b'')
ctx.rule('EXCEPTION_ENTRY', b'{START_PC}{END_PC}{HANDLER_PC}{CATCH_TYPE}')
ctx.bytes('START_PC', 2)
ctx.bytes('END_PC', 2)
ctx.bytes('HANDLER_PC', 2)
ctx.bytes('CATCH_TYPE', 2)
ctx.rule('CODE_ATTRS', b'{CODE_ATTR_COUNT}{CODE_ATTR_INFO}')
ctx.bytes('CODE_ATTR_COUNT', 2)
ctx.rule('CODE_ATTR_INFO', b'{LINE_NUMBER_TABLE}')
ctx.literal('CODE_ATTR_INFO', b'')
ctx.rule('LINE_NUMBER_TABLE', b'{LNT_NAME}\x00\x00\x00\x08\x00\x01\x00\x00\x00\x01')
ctx.bytes('LNT_NAME', 2)
ctx.rule('ATTRIBUTES', b'{ATTR_COUNT}{ATTR_INFO}')
ctx.bytes('ATTR_COUNT', 2)
ctx.rule('ATTR_INFO', b'{SOURCE_FILE_ATTR}')
ctx.literal('ATTR_INFO', b'')
ctx.rule('SOURCE_FILE_ATTR', b'{SF_NAME}\x00\x00\x00\x02{SF_INDEX}')
ctx.bytes('SF_NAME', 2)
ctx.bytes('SF_INDEX', 2)
