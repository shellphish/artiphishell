repo_classes:

  # Metadata
  crs_tasks: MetadataRepository
  c_crs_tasks: MetadataRepository
  java_crs_tasks: MetadataRepository
  project_metadatas: MetadataRepository
  crs_tasks_cancelled: MetadataRepository
  project_harness_infos: MetadataRepository
  target_split_metadatas: MetadataRepository
  project_analysis_sources: FilesystemRepository
  crs_tasks_oss_fuzz_repos: FilesystemRepository
  project_build_configurations: MetadataRepository
  codeql_analysis_ready: MetadataRepository
  base_project_metadatas: MetadataRepository
  fuzzers_started: BlobRepository
  
  # Inputs
  codeswipe_rankings: BlobRepository
  crs_tasks_diffs: BlobRepository
  discovery_guy_output_seeds: BlobRepository
  full_functions_indices: BlobRepository
  full_functions_jsons_dirs: FilesystemRepository

  aijon_build_artifacts: {cls: FilesystemRepository, required: false}
  aijon_instrumentation_artifacts: {cls: FilesystemRepository, required: false}
  

  ################### OUTPUTS #####################
  benign_harness_inputs: BlobRepository
  benign_harness_inputs_metadatas: MetadataRepository

  crashing_harness_inputs: BlobRepository
  crashing_harness_inputs_metadatas: MetadataRepository
  ################# INTERMEDIATES #################
  
  # raw_benign_harness_inputs:
  #   cls: BlobRepository
  #   required: false
  # raw_crashing_harness_inputs:
  #   cls: BlobRepository
  #   required: false

tasks:
  aijon_instrument_from_codeswipe:
    priority: 2
    job_quota:
      cpu: 5
      mem: "16Gi"
    timeout:
      minutes: 60

    links:
      project_id:
        repo: crs_tasks
        kind: InputId

      project_analysis_source:
        repo: project_analysis_sources
        kind: InputFilepath

      codeql_analysis_ready:
        repo: codeql_analysis_ready
        kind: InputFilepath

      crs_task:
        repo: crs_tasks
        kind: InputMetadata

      project_cancel:
        repo: crs_tasks_cancelled
        kind: Cancel

      project_metadata:
        repo: project_metadatas
        kind: InputMetadata

      functions_index:
        repo: full_functions_indices
        kind: InputFilepath

      functions_jsons_dir:
        repo: full_functions_jsons_dirs
        kind: InputFilepath

      codeswipe_ranking:
        repo: codeswipe_rankings
        kind: InputFilepath
      
      aijon_instrumentation_artifact:
        repo: aijon_instrumentation_artifacts
        kind: OutputFilepath

    executable:
      cls: Container
      args:
        image: aixcc-aijon

        host_mounts:
          "/var/run/docker.sock": "/var/run/docker.sock"
          "/shared/": "/shared/"
        template: |
          set -x
          set -e

          export CRS_TASK_NUM={{ crs_task.concurrent_target_num | default('1') }}
          export LANGUAGE={{ project_metadata.language | shquote }}

          export POI_TYPE="codeswipe"

          export PROJECT_ID={{ project_id | shquote }}
          export PROJECT_NAME={{ crs_task.project_name | shquote }}
          export CODESWIPE_REPORT={{ codeswipe_ranking | shquote }}
          export FULL_FUNCTION_INDICES={{ functions_index | shquote }}
          export TARGET_FUNCTIONS_JSONS_DIR={{ functions_jsons_dir | shquote }}
          export CRS_TASK_ANALYSIS_SOURCE={{ project_analysis_source | shquote }}
          export INSTRUMENTATION_ARTIFACTS={{ aijon_instrumentation_artifact | shquote }}

          /aijon/run_scripts/run-aijon-instrument.sh

  # aijon_instrument_from_diff:
  #   priority: 2
  #   job_quota:
  #     cpu: 0.5
  #     mem: "2Gi"
  #   timeout:
  #     minutes: 30

  #   links:
  #     project_id:
  #       repo: crs_tasks
  #       kind: InputId

  #     # For delta mode currently
  #     # For patched version of source, we might need something else
  #     project_analysis_source:
  #       repo: project_analysis_sources
  #       kind: InputFilepath


  #     project_cancel:
  #       repo: crs_tasks_cancelled
  #       kind: Cancel

  #     functions_index:
  #       repo: full_functions_indices
  #       kind: InputFilepath

  #     functions_jsons_dir:
  #       repo: full_functions_jsons_dirs
  #       kind: InputFilepath

  #     crs_task:
  #       repo: crs_tasks
  #       kind: InputMetadata

  #     crs_task_diff:
  #       repo: crs_tasks_diffs
  #       kind: InputFilepath

  #     aijon_instrumentation_artifact:
  #       repo: aijon_instrumentation_artifacts
  #       kind: OutputFilepath

  #   executable:
  #     cls: Container
  #     args:
  #       image: aixcc-aijon

  #       host_mounts:
  #         "/var/run/docker.sock": "/var/run/docker.sock"
  #         "/shared/": "/shared/"
  #       template: |
  #         set -x
  #         set -e

  #         export CRS_TASK_NUM={{ crs_task.concurrent_target_num | default('1') }}
  #         export POI_TYPE="diff"
  #         export DIFF_PATCH_FILE={{ crs_task_diff | shquote }}
  #         export FULL_FUNCTION_INDICES={{ functions_index | shquote }}
  #         export TARGET_FUNCTIONS_JSONS_DIR={{ functions_jsons_dir | shquote }}
  #         export CRS_TASK_ANALYSIS_SOURCE={{ project_analysis_source | shquote }}
  #         export INSTRUMENTATION_ARTIFACTS={{ aijon_instrumentation_artifact | shquote }}

  #         /aijon/run_scripts/run-aijon-instrument.sh

  #         ls -la ${INSTRUMENTATION_ARTIFACTS}

  aijon_build:
    priority: 2
    job_quota:
      cpu: 0.5
      mem: "4Gi"

    links:
      build_configuration:
        repo: project_build_configurations
        kind: InputMetadata

      aijon_instrumentation_artifact:
        repo: aijon_instrumentation_artifacts
        kind: InputFilepath
        key: build_configuration.project_id
 
      project_id:
        repo: crs_tasks
        kind: InputId
        key: build_configuration.project_id
      crs_task:
        repo: crs_tasks
        kind: InputMetadata
        key: build_configuration.project_id
      project_cancel:
        repo: crs_tasks_cancelled
        kind: Cancel
        key: build_configuration.project_id

      project_metadata:
        repo: project_metadatas
        kind: InputMetadata
        key: build_configuration.project_id

      project_oss_fuzz_repo:
        repo: crs_tasks_oss_fuzz_repos
        kind: InputFilepath
        key: build_configuration.project_id
      
      project_analysis_source:
        repo: project_analysis_sources
        kind: InputFilepath
        key: build_configuration.project_id
     
      # OUTPUTS
      aijon_build_artifact:
        repo: aijon_build_artifacts
        kind: OutputFilepath

    executable:
      cls: Container
      args:
        image: aixcc-aijon

        host_mounts:
          "/var/run/docker.sock": "/var/run/docker.sock"
          "/shared/": "/shared/"
        template: |
          set -x
          set -e

          export IN_PIPELINE="1"

          export CRS_TASK_NUM={{ crs_task.concurrent_target_num | default('1') }}
          export LANGUAGE={{ project_metadata.language | shquote }}

          export PROJECT_ID={{ project_id | shquote }}
          export BUILD_ARTIFACTS={{ aijon_build_artifact | shquote }}
          export BUILD_SANITIZER={{ build_configuration.sanitizer | shquote }}
          export INSTRUMENTATION_ARTIFACTS={{ aijon_instrumentation_artifact | shquote }}
          export BUILD_ARCHITECTURE={{ build_configuration.architecture | shquote }}
          export OSS_FUZZ_PROJECT_DIR={{ project_oss_fuzz_repo | shquote }}/projects/{{ crs_task.project_name | shquote }}/
          export CRS_TASK_ANALYSIS_SOURCE={{ project_analysis_source | shquote }}

          export BUILD_PATCH_FILE=${INSTRUMENTATION_ARTIFACTS}/aijon_instrumentation.patch
          export AFL_ALLOW_LIST=${INSTRUMENTATION_ARTIFACTS}/aijon_allowlist.txt
          /aijon/run_scripts/run-aijon-build.sh

  aijon_fuzz_aflpp:
    long_running: true

    # We limit how many total jobs for this task can be running at once
    # It will scale up the node pool until it reaches this number
    # TODO(FINALDEPLOY): this should be templated based on the # of crs tasks

    # This will call a function to determine what fuzzing pool to use based crs_task.fuzzing_pool_name
    node_labels_function: "task_pool_labels"

    node_labels:
      support.shellphish.net/allow-fuzzing: "true"
    # It can also run on the fuzzing only nodes
    node_taints:
      support.shellphish.net/only-fuzzing: "true"
    # Prioritize launching on these nodes
    node_affinity:
      support.shellphish.net/only-fuzzing: "true"

    replica_node_taints:
      kubernetes.azure.com/scalesetpriority: "spot"
    replica_node_affinity:
      kubernetes.azure.com/scalesetpriority: "spot"


    job_quota:
      cpu: 1
      mem: "3.6Gi"

    timeout:
      minutes: 3000

    links:
      # The project_id is provided by the run request

      harness_info_id:
        repo: project_harness_infos
        kind: InputId
      harness_info:
        repo: project_harness_infos
        kind: InputMetadata

      # Wait until the fuzzers are ready before we schedule this task
      fuzzers_started:
        repo: fuzzers_started
        kind: InputId

      build_configuration:
        repo: project_build_configurations
        kind: InputMetadata
        key: harness_info.build_configuration_id

      target_split_metadata:
        repo: target_split_metadatas
        kind: InputMetadata
        key: build_configuration.project_id

      crs_task:
        repo: c_crs_tasks
        kind: InputMetadata
        key: build_configuration.project_id
      project_cancel:
        repo: crs_tasks_cancelled
        kind: Cancel
        key: build_configuration.project_id

      project_id:
        repo: project_analysis_sources
        kind: InputId
        key: build_configuration.project_id
      project_sources:
        repo: project_analysis_sources
        kind: InputFilepath
        key: build_configuration.project_id
      project_metadata:
        repo: project_metadatas
        kind: InputMetadata
        key: build_configuration.project_id
      discovery_guy_corpus_dir:
        repo: discovery_guy_output_seeds
        kind: StreamingInputFilepath

      # The /src/ /work/ and /out/ directories which will be mounted into the container
      aijon_build_artifact_dir:
        repo: aijon_build_artifacts
        kind: InputFilepath
        key: harness_info.build_configuration_id

    executable:
      cls: Container
      args:
        privileged: true
        image: "{{ crs_image_prefix | default('') }}shellphish-oss-fuzz-runner-{{crs_task.project_name}}--shellphish_aijon"
        host_mounts:
          "/shared/": "/shared/"
          "/src/": "/tmp/src.{{ harness_info_id }}_aijon"
          "/out/": "/tmp/out.{{ harness_info_id }}_aijon"
          "/work/" : "/tmp/work.{{ harness_info_id }}_aijon"
        template: |
          set -ex

          export CRS_TASK_NUM={{ crs_task.concurrent_target_num | default('1') }}

          export PROJECT_NAME={{ crs_task.project_name | shquote }}
          export PROJECT_ID={{ project_id }}

          export HARNESS_INFO_ID={{ harness_info_id | shquote}}
          export HARNESS_NAME={{ harness_info.cp_harness_name | shquote }}
          export BUILD_ARTIFACT_DIR={{ aijon_build_artifact_dir | shquote }}/artifacts/

          export ARTIPHISHELL_PROJECT_NAME={{ crs_task.project_name | shquote }}
          export ARTIPHISHELL_HARNESS_NAME={{ harness_info.cp_harness_name | shquote }}
          export ARTIPHISHELL_HARNESS_INFO_ID={{ harness_info_id | shquote }}
          export ARTIPHISHELL_FUZZER_SYNC_DIR="/shared/fuzzer_sync/${ARTIPHISHELL_PROJECT_NAME}-${ARTIPHISHELL_HARNESS_NAME}-${ARTIPHISHELL_HARNESS_INFO_ID}/"
          mkdir -p "$ARTIPHISHELL_FUZZER_SYNC_DIR"
          export ARTIPHISHELL_FUZZER_INSTANCE_NAME_FULL="{{project_id}}-${JOB_ID}-${REPLICA_ID}"
          export ARTIPHISHELL_FUZZER_INSTANCE_NAME="secondary-$(echo $ARTIPHISHELL_FUZZER_INSTANCE_NAME_FULL | md5sum | cut -d' ' -f1)"
          echo "secondary-$ARTIPHISHELL_FUZZER_INSTANCE_NAME_FULL" > "$ARTIPHISHELL_FUZZER_SYNC_DIR/$ARTIPHISHELL_FUZZER_INSTANCE_NAME.fullname"

          export FUZZING_LANGUAGE=$(yq -r '.language' "$BUILD_ARTIFACT_DIR/out/build_metadata.yaml")
          export SANITIZER=$(yq -r '.sanitizer' "$BUILD_ARTIFACT_DIR/out/build_metadata.yaml")
          export FUZZING_ENGINE=$(yq -r '.fuzzing_engine' "$BUILD_ARTIFACT_DIR/out/build_metadata.yaml")
          export RUN_FUZZER_MODE=interactive

          export DISCOVERY_GUY_CORPUS_DIR={{ discovery_guy_corpus_dir | shquote }}

          mkdir -p /src
          mkdir -p /work
          mkdir -p /out

          # Overwrite the working directory to be the root of the container
          WD=$(pwd)
          cd /

          # We are going to use a lockfile to ensure that only one instance is copying the data per node
          LOCKFILE="/src/.rsync.lock"
          while true; do

          if ( set -o noclobber; echo "$$" > "$LOCKFILE") 2> /dev/null; then
              if [ -f /out/.rsync_complete ]; then
              # Skip sync if we already have the files for this configuration on this node
              rm -f "$LOCKFILE"
              break
              fi

              trap 'rm -f "$LOCKFILE"; exit $?' INT TERM EXIT

              # Copy the data over
              # The target source gets copied over the source in current directory
              for dir in src work out; do
              if [ -d "$BUILD_ARTIFACT_DIR"/$dir ]; then
                  rm -rf /$dir/*
                  rsync -ra "$BUILD_ARTIFACT_DIR"/$dir/ /$dir/
              fi
              done
              touch /out/.rsync_complete

              rm -f "$LOCKFILE"
              trap - INT TERM EXIT
              break
          else
              sleep 1
          fi
          done

          ls -al /src/
          ls -al /work/
          ls -al /out/

          cd $WD

          touch /out/aijon_fuzz_${JOB_ID}_${REPLICA_ID}.stdout.log
          touch /out/aijon_fuzz_${JOB_ID}_${REPLICA_ID}.stderr.log

          # Final bash command to run
          (
          set -e

          run_fuzzer $HARNESS_NAME

          if [ $? -eq 0 ]; then
          touch /out/.run_success
          fi
          ) 2> /out/aijon_fuzz_${JOB_ID}_${REPLICA_ID}.stderr.log | tee /out/aijon_fuzz_${JOB_ID}_${REPLICA_ID}.stdout.log || true

          echo "===== STDOUT ====="
          cat /out/aijon_fuzz_${JOB_ID}_${REPLICA_ID}.stdout.log
          echo "===== STDERR ====="
          cat /out/aijon_fuzz_${JOB_ID}_${REPLICA_ID}.stderr.log
          echo "=================="

          touch /out/aijon_fuzz_metadata_${JOB_ID}_${REPLICA_ID}.yaml
          echo "harness_info_id: ${HARNESS_INFO_ID}" >> /out/aijon_fuzz_metadata_${JOB_ID}_${REPLICA_ID}.yaml
          echo "harness_name: ${HARNESS_NAME}" >> /out/aijon_fuzz_metadata_${JOB_ID}_${REPLICA_ID}.yaml
          echo "project_id: ${PROJECT_ID}" >> /out/aijon_fuzz_metadata_${JOB_ID}_${REPLICA_ID}.yaml

          if [ -f /out/.run_success ]; then
          echo "run_success: true" >> /out/aijon_fuzz_metadata_${JOB_ID}_${REPLICA_ID}.yaml
          else
          echo "run_success: false" >> /out/aijon_fuzz_metadata_${JOB_ID}_${REPLICA_ID}.yaml
          fi
          echo "FUZZ METADATA: "
          cat /out/aijon_fuzz_metadata_${JOB_ID}_${REPLICA_ID}.yaml

  aijon_fuzz_jazzer:
    long_running: true

    # Avoid spamming pull requests when we launch many instances of this task
    wait_for_image_pull: true

    # This will call a function to determine what fuzzing pool to use based crs_task.fuzzing_pool_name
    node_labels_function: "task_pool_labels"

    # Limit this job to only run on nodes which allow fuzzing
    node_labels:
      support.shellphish.net/allow-fuzzing: "true"
    # It can also run on the fuzzing only nodes
    node_taints:
      support.shellphish.net/only-fuzzing: "true"

    # Prioritize launching on these nodes
    node_affinity:
      support.shellphish.net/only-fuzzing: "true"

    # To enable us to use the cheaper spot nodes
    # But we only allow replicas because they may be evicted
    replica_node_taints:
      kubernetes.azure.com/scalesetpriority: "spot"
    replica_node_affinity:
      kubernetes.azure.com/scalesetpriority: "spot"

    job_quota:
        cpu: 1
        mem: "4Gi"
    timeout:
      minutes: 3000

    links:
      # The project_id is provided by the run request

      harness_info_id:
        repo: project_harness_infos
        kind: InputId
      harness_info:
        repo: project_harness_infos
        kind: InputMetadata
        
      # Wait until the fuzzers are ready before we schedule this task
      fuzzers_started:
        repo: fuzzers_started
        kind: InputId

      build_configuration:
        repo: project_build_configurations
        kind: InputMetadata
        key: harness_info.build_configuration_id

      target_split_metadata:
        repo: target_split_metadatas
        kind: InputMetadata
        key: build_configuration.project_id

      crs_task_id:
        repo: java_crs_tasks
        kind: InputId
        key: build_configuration.project_id
      crs_task:
        repo: java_crs_tasks
        kind: InputMetadata
        key: build_configuration.project_id

      project_id:
        repo: project_analysis_sources
        kind: InputId
        key: build_configuration.project_id
      project_cancel:
        repo: crs_tasks_cancelled
        kind: Cancel
        key: build_configuration.project_id
      project_sources:
        repo: project_analysis_sources
        kind: InputFilepath
        key: build_configuration.project_id
        template_cache_key: "project_analysis_sources-{{ build_configuration.project_id }}"
      project_metadata:
        repo: base_project_metadatas
        kind: InputMetadata
        key: build_configuration.project_id
      project_metadata_path:
        repo: base_project_metadatas
        kind: InputFilepath
        key: build_configuration.project_id

      jazzer_build_artifacts_dir:
        repo: aijon_build_artifacts
        kind: InputFilepath
        key: harness_info.build_configuration_id

    executable:
      cls: Container
      args:
        privileged: true
        image: "{{ crs_image_prefix | default('') }}shellphish-oss-fuzz-runner-{{crs_task.project_name}}--shellphish_jazzer"

        host_mounts:
          "/shared/": "/shared/"
  
        template: |
          set -x
          set -e

          export CRS_TASK_NUM={{ crs_task.concurrent_target_num | default('1') }}

          export SHELLPHISH_BUILD_ARTIFACTS_DIR={{ jazzer_build_artifacts_dir | shquote }}/artifacts/

          export ARTIPHISHELL_PROJECT_NAME={{ crs_task.project_name | shquote }}
          export ARTIPHISHELL_HARNESS_NAME={{ harness_info.cp_harness_name | shquote }}
          export ARTIPHISHELL_HARNESS_INFO_ID={{ harness_info_id | shquote }}
          export ARTIPHISHELL_SHELLPHISH_PROJECT_ID={{ project_id | shquote }}
          export FUZZING_ENGINE="libfuzzer"
          export RUN_FUZZER_MODE=interactive

          mkdir -p /src
          mkdir -p /work
          mkdir -p /out

          # Overwrite the working directory to be the root of the container
          WD=$(pwd)
          cd /

          # The target source gets copied over the source in current directory
          for dir in src work out; do
            if [ -d "$SHELLPHISH_BUILD_ARTIFACTS_DIR"/$dir ]; then
              rm -rf /$dir/
              rsync -ra "$SHELLPHISH_BUILD_ARTIFACTS_DIR"/$dir/ /$dir/
            fi
          done

          ls -al /src/
          ls -al /work/
          ls -al /out/

          cd $WD/out
          echo "Running fuzzing in $PWD"

          # Fuzzing and seeds dir for Jazzer for each harness
          
          export JAZZER_INSTANCE_UNIQUE_NAME=${ARTIPHISHELL_PROJECT_NAME}-${ARTIPHISHELL_HARNESS_NAME}-${ARTIPHISHELL_HARNESS_INFO_ID}/

          # save aijon seeds to sync-* so jazzer_same_node_sync takes care of syncing of seeds
          export ARTIPHISHELL_FUZZER_SYNC_PATH="/shared/fuzzer_sync/$JAZZER_INSTANCE_UNIQUE_NAME/"

          export ARTIPHISHELL_JAZZER_BENIGN_SEEDS="$ARTIPHISHELL_FUZZER_SYNC_PATH/sync-aijon-java/queue/"
          export ARTIPHISHELL_JAZZER_CRASHING_SEEDS="$ARTIPHISHELL_FUZZER_SYNC_PATH/jazzer-minimized/crashes/"
          mkdir -p "$ARTIPHISHELL_JAZZER_CRASHING_SEEDS" "$ARTIPHISHELL_JAZZER_BENIGN_SEEDS"

          echo "ARTIPHISHELL_JAZZER_CRASHING_SEEDS: $ARTIPHISHELL_JAZZER_CRASHING_SEEDS"
          echo "ARTIPHISHELL_JAZZER_BENIGN_SEEDS: $ARTIPHISHELL_JAZZER_BENIGN_SEEDS"

          export CORPUS_DIR=$ARTIPHISHELL_JAZZER_BENIGN_SEEDS # run_fuzzer needs this to be set
          
          # SHELLPHISH JAZZER
          export ARTIPHISHELL_JAZZER_BINARY="/out/shellphish/jazzer-aixcc/jazzer-build/jazzer_driver"
          export ARTIPHISHELL_JAZZER_AGENT="/out/shellphish/jazzer-aixcc/jazzer-build/jazzer_agent_deploy.jar"
          touch /shellphish/dict.txt

          export MODE=fuzz

          # crash reports and fuzzing log for debugging
          export ARTIPHISHELL_JAZZER_CRASH_REPORTS="${ARTIPHISHELL_FUZZER_SYNC_PATH}/aijon-java-debug-info/crash_reproducer"
          ARTIPHISHELL_JAZZER_FUZZING_LOG_DIR="${ARTIPHISHELL_FUZZER_SYNC_PATH}/aijon-java-debug-info/logs/"
          mkdir -p "$ARTIPHISHELL_JAZZER_CRASH_REPORTS" "$ARTIPHISHELL_JAZZER_FUZZING_LOG_DIR"
          export ARTIPHISHELL_JAZZER_FUZZING_LOG=$ARTIPHISHELL_JAZZER_FUZZING_LOG_DIR/"${TASK_NAME}_${REPLICA_ID}"

          export PROJECT_METADATA_PATH={{ project_metadata_path | shquote }}

          export ARTIPHISHELL_IJON_MODE="1"

          run_fuzzer {{harness_info.cp_harness_name | shquote}}
   
