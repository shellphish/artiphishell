
import logging
import tempfile
import os
import subprocess
import yaml

from pathlib import Path
from agentlib import Code
from typing import Any, Tuple, List, Type, Union

from shellphish_crs_utils.oss_fuzz.project import OSSFuzzProject
from shellphish_crs_utils.models.oss_fuzz import AugmentedProjectMetadata

from .verification_passes import *

from ..config import Config, PatcherqMode

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

NAIVE_VERIFICATION_PASSES = [CompilerVerificationPass, CrashVerificationPass]

if Config.use_build_check_pass:
    REGULAR_VERIFICATION_PASSES = [CompilerVerificationPass, BuildCheckVerificationPass, CrashVerificationPass, TestsVerificationPass]
    SARIF_VERIFICATION_PASSES = [CompilerVerificationPass, BuildCheckVerificationPass, TestsVerificationPass]
else:
    REGULAR_VERIFICATION_PASSES = [CompilerVerificationPass, CrashVerificationPass, TestsVerificationPass]
    SARIF_VERIFICATION_PASSES = [CompilerVerificationPass, TestsVerificationPass]

class PatchVerifier:
    '''
    This class is responsible for verifying the patch generated by the PatchGenerator.
    It runs a series of verification passes to ensure that the patch is correct.
    If any of the verification passes fail, an exception will be raised.
    '''

    def __init__(self, cp, patch:dict, git_diff:str, functions_in_patch: list, language: str, root_cause_report: str, patcherq: str, all_args:dict):
        self.cp = cp
        self.patch = patch
        self.git_diff = git_diff
        self.functions_in_patch = functions_in_patch
        self.all_args = all_args
        self.patcherq = patcherq
        self.root_cause_report = root_cause_report
        self.build_request_id = None
        self.language = language

        self.use_task_service = os.getenv('LOCAL_RUN') != 'True'

        with open(all_args['project_yaml'], 'r') as f:
            self.project_yaml = AugmentedProjectMetadata.model_validate(yaml.safe_load(f))

        # We are gonna work on a fresh copy of the repo
        # so we don't pollute the original one.
        # NOTE: the original cp remain unbuilt, we are building in the new_cp!
        self.new_cp = self.get_fresh_repo()

        # Initialize the verification passes 
        self.verification_passes = []
        if Config.patcherq_mode == PatcherqMode.SARIF:
            active_verification_passes = SARIF_VERIFICATION_PASSES.copy()
        else:
            active_verification_passes = REGULAR_VERIFICATION_PASSES.copy()
            
        if Config.use_critic:
            active_verification_passes.append(CriticPass)
        
        if Config.use_reg_pass:
            active_verification_passes.append(RegressionVerificationPass)
            
        if Config.use_fuzz_pass and not (Config.patcherq_mode == PatcherqMode.SARIF):
            active_verification_passes.append(FuzzVerificationPass)
            
        for verification_pass in active_verification_passes:
            self.verification_passes.append(verification_pass(cp=self.new_cp, clean_cp=self.cp, patch=patch, git_diff=git_diff, functions_in_patch=functions_in_patch, language=language, root_cause_report=root_cause_report, patcherq=patcherq, all_args=all_args))

    def get_fresh_repo(self):
        # Create the directory structure for the new project
        new_folder = tempfile.mkdtemp(dir=f"/shared/patcherq/{self.all_args['project_id']}/")
        new_oss_fuzz_dir = os.path.join(new_folder, "oss-fuzz", "projects", self.cp.project_name)
        new_source_dir = os.path.join(new_folder, "source-root")
        os.makedirs(new_source_dir, exist_ok=True)
        os.makedirs(new_oss_fuzz_dir, exist_ok=True)

        # Now copy the source to the new temporary folder
        # NOTE: These copies are always done from an ****UN-BUILT**** Challenge Project, thus there 
        #       is no need of wiping the artifacts folder.
        subprocess.check_call(["cp", "-a", f"{self.cp.project_path}/.", new_oss_fuzz_dir])
        subprocess.check_call(["cp", "-a", f"{self.cp.project_source}/.", new_source_dir])

        # This is the new ChallengeProject object that we are 
        # gonna use for compilation and verification
        return OSSFuzzProject(
                              project_id = self.all_args['project_id'],
                              oss_fuzz_project_path=Path(new_oss_fuzz_dir),
                              augmented_metadata=self.project_yaml,
                              project_source=Path(new_source_dir),
                              use_task_service=self.use_task_service
                             )

    def run(self) -> Union[None, OSSFuzzProject]:
        # Run all the verification passes
        # If any of the verification passes fail, an exception will be raised
        for verifier in self.verification_passes:
            logger.info("ðŸ”¬ Running %s now...", verifier.__name__)
            verifier.run()
            logger.info("  âœ… %s passed!", verifier.__name__)
            if isinstance(verifier, CompilerVerificationPass):
                self.build_request_id = verifier.build_request_id

        # NOTE: this is returning the patched challenge project.
        #       the compilation pass is operating on a copy of the original ChallengeProject created by the constructor of the
        #       PatchVerifier. The building process will create the artifacts in the new project directory.
        #       These new artifacts are verified by the CrashPass and TestPass.
        return self.new_cp
