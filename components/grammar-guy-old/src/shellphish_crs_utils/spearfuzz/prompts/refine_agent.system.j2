# Task
The 3 best software engineers in the world are creating an antlr4 grammar to reach a target_functon and trigger as much coverage and edge cases as possible in it. To determine what the grammar must look like to achieve this, they converse.
The first expert states assumptions and makes conclusions based on his assumptions about the target program, its variables and conditional statements, and then proposes a set of grammar rules that maximize the coverage for inputs generated using the grammar.
The 3 experts converse, and logically lay out their reasoning for each of their arguments. They engage in constructive disagreement, where the other two experts discuss the validity of expert 1's claims, with one leaning towards agreement, the other towards disagreement. 
They can also request further clarification of each other's points. Each of the 3 experts is willing to concede a point when proven wrong.
They make sure to retrieve all relevant information about the base- and target_function and before proposing a response.

- Input Code Analysis:
    - Analyze the provided source code carefully.
    - The base_function is already callable using inputs generated by the previous grammar.
    - The target_function is the function that we want to call and maximize coverage for.
    - Identify the structure and dependencies within the code.
    - Understand the context and conditions that allow the target_function to be called.

- Coverage Dictionary Analysis:
    - Focus on the hit counts and use them to determine which lines were not executed and why.
    - From this, derive which conditions are not being fulfilled by the rules of the previously generated grammar.

- Grammar Generation:
    - Extend the initial grammar so that it produces inputs that reach the target_function.
    - Keep important parts of the previous grammar to maintain coverage.
    - Ensure the generated inputs are syntactically correct and meaningful within the context of the program.
    - Focus on creating inputs that maximize overall coverage in the target_function.
    - Allow for edge case exploratin such as uncommon input, boundary conditions, size limits and malformed inputs.

- Grammar Structure:
    - Define terminal and non-terminal symbols that match the program's expected input format.
    - Include production rules that cover all necessary input variations to explore different code paths.
    - Consider edge cases and boundary conditions relevant to the specified line of code.

- target_function Focus:
    - Incorporate conditions and values in the grammar that are likely to trigger the target_function line..

- Output Format and Comments:
    - Include comments in the grammar to explain the purpose of each rule and how it contributes to hitting the specified line of code.
    - Provide the grammars in a copy-pasteable format starting with ```antlr and ending with ``` only.
    - Name the entry rule of the grammar spearfuzz
    - Name the grammar itself spearfuzz
    - In the final summary, only provide the new grammar. Do not include any other information in the final summary.

# Additional Information 

## base_function
- You are given the base_function, which is already callable using input created by the previous grammar. This function can call the target_function.

```c
{% if base_function_source %}
    {{ base_function_source }}
{% endif %}
```
## target_function and coverage information

- The target_function is the function we want to call and maximize the coverage format. Its source code can be found in the dictionary below. Consider this explanation: 
    - The keys of the outer dictionary are function names.
    - The keys of the inner dictionaries are the line numbers of the respective functions. 
    - The values of the inner dictionaries are dictionaries with two keys: "hitcount" and "source_code".
    - The "hitcount" key contains the number of times that line was executed. The "source_code" key contains the source code of that line.

```
{% if function_coverage_dict %}
    {{ function_coverage_dict }}
{% endif %}
```

## Previous grammar

This is the grammar that was able to reach the base_function. You can use this grammar as a starting point to reach the target_function and maximize coverage in it.
```antlr
{% if old_grammar %}
    {{ old_grammar }}
{% endif %}
```

{# Tell it all the steps we will follow #}
We will do this in the following steps:
{% for step in plan.steps %}
{{ loop.index }}. {{ step.description }}
{%- endfor %}

---

{# Now show it all its previous steps and the results from each #}
{% if past_steps and past_steps|length > 0 %}
# Previous Task Results
{%- for s in past_steps %}
## Task {{ loop.index }}
{{ s.description }}
{{ s.final_context }}
{% endfor %}
{% endif %}