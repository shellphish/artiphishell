1:
  name: "summarize_function"
  description: "Read the code of the commit function and summarize what it does.
    "

2:
  name: "determine_vulnerability"
  description: "
    Analyze the code of the commit function and determine whether there is any potential vulnerability in the code.
    Reply `yes` if you think there is a potential vulnerability, otherwise reply `no`.
    "

3:
  name: "explain_vulnerability"
  description: "
    Explain why you think the commit function is vulnerable. 
    "
4:
  name: "summarize_harness"
  description: "Read the code of the harness and summarize what it does"

5: 
  name: "determine_reachibility"
  description: "
    Please analyze the code and determine whether the commit function is reachable from the harness.
    Reply `yes` if it is reachable, otherwise reply `no`. And give a brief reasoning of your answer.
    We will provide you the call chains we found via static analysis that calls the vulnerable functions"

6:
  name: "propose_seed"
  description: 
    "Based on your analysis, please propose a triggering method to trigger the vulnerability in the commit function. 
    And also provide a input seed that can trigger the vulnerability in the commit function from the harness."

7:
  name: "refine_seed"
  description:
    "
    In the seed you generated in the last step,
    If the vulnerability is one of the following types:
    {% for i, name in enumerate(vulnerability_types) %}
     {{ name }}
    {% endfor %} 
    You should substitute the input you pass to the sink from the last step to a magic string.
    The following is a json that describes magic strings to the corresponding vulnerabilities.
    In the given json, there is a list of dictrionary.
    Each dictionary represents a vulnerability type, and have three fields: `Vulnerability Classs`, `Sink Class or Method` and `Magic String`.
    When you see the sink method or class from  `Sink Class or Method`, you should pass the `Magic String` as an argument to sink method or class.
    For example, if the sink method or class is in FileWriter, File, read or write.
    You should call this method with the corresponding magic string.

    We provide two examples here:

    exmaple 1:
    If you identify the sink class is a call to class `File` and the vulnerability type is file read and write.
    Accoring to the json we provide you, the magic string to file read and write should be `jazzer`
    Then you should pass `jazzer` as the file name to `File`, so if you identify the vulnerability is file read and write, the constructer of File should be File('jazzer') .
    And if you identify the vulnerability is File path traversal, the constructer of File should look like `File('../../jazzer-traversal')`

    example 2:
    Another example is if you identigy the sink class is a call to class `ProcessBuilder`, then the magic string is `jazze`.
    Then you should pass `jazze` to `ProcessBuilder` like ProcessBuiler('jazze'). 

    A special case is deserialization, what we provide as a magic string is the hex format of the actually magic string.
    All the other magic string are string literal and can directly pass to sink.
    Only for deserialization, you should pass a hex decoding the magic string to `ObjectStreamInput`.
    You MUST pass the correct magic string to the sink method or class, if there is any, to trigger the sink correctl. 
    We only need to pass it once. Do not pass it multiple times.
    And for those sink method does not have a corresponding magic string, just pass an input that can trigger the vulnerability.
    Please find the magic string of this vulneraability if there is any and put it in the correct part of the input.
    
    But if the vulnerability in the sink function is not of the above types, you can trigger the vulnerability using inputs that you think it is most likely to succeed."


8:
  name: "generate_script"
  description:
    "Based on the analysis and the seed you proposed. 
    please write a python script that will convert the input seed to bytes. it has to match the size in the seed_structure and save it in a binary file called output.bin. 
    But if it is a pather traversal bug, the script should generate 5 inputs. The first input should have `../../jazzer-traversal`, the second will add one `../` before the first input, etc.
    The 5 generated inputs should be named after output.bin.0 - ouput.bin.4 and all of them should be put in a directory called `output`.
    For all the other vulnerabilities, direclty write the input seed to `output.bin`, do not put it in `output` directory.
    For example a 2 bytes integer 13 is 000d in big endian. PLEASE USE Python and output the script in the following format.
    ```python
      {script}
    ```"
9:
  name: "review_script"
  description:
    "Review the script you generated in the last step. Make sure the script is correct and will generate the correct input seed. 
    If you are uncertain of how to directly trigger the vulnerability in the sink function, you can try to generate the input that can explore as many functions as possible.
    For example, if the harness expects a http request, you can try to generate a request that can trigger as many endpoints on the path with more headers and parameters as long as they are valid.
    Or if the harness expect a file format, you can try to generate a file that can trigger as many file parsing functions as possible on the path.
    If you find any issues, please fix them and generate the script again. PLEASE USE Python and output the script in the following format.
    If the input you need to generate contains file format, you can use corresponsing or suitable python library to help you generate it instead of constructing the whole input directly.
    ```python
      {script}
    ```"