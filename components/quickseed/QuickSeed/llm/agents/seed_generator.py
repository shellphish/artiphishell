#!/usr/bin/env python3
import logging
import os

from pathlib import Path
from typing import Optional, Any, List
from pathlib import Path


from agentlib import (

    AgentPlanStep,
    SaveLoadObject,
    Field,
    AgentPlanStepAttempt,
)
from .base_agent import BaseAgent
_l = logging.getLogger(__name__)


class HaOutput(SaveLoadObject):
    """
    This object describes the seed generated.
    - key1: value_description.
    - key1: value_description.
    """
    reachable: str = Field(
        default="No", description="""
        `Yes` or `No` to indicate whether the functions is reachable from the harness.
        """
    )
    # seed: Any = Field(
    #     default="No", description="the input seed that will trigger the harness"
    # )
    generate_seed_python_script: str = Field(
        default="No", description="""
        If it is not reachable, leave this field as `No`. Only fill this field when it is reachable from harness.
        The python script produced in the last task. This python script generates the seed input and save it to `output.bin` or `output` directory.
        Please make sure that the `output.bin` or `output` is generated by running `python3 <script.py>`. 
        If you write functions in the script, please make sure you have  main function to call them in the script.
        """
    )
    # seed_structure: str = Field(
    #     default="No", description="explain the seed structure and break it down for me"
    # )
    # source_func: str = Field(
    #     default="No",
    #     description="output the function that this harness is going to trigger",
    # )

class DetermineReachibilityOutput(SaveLoadObject):
    """
    This object describes whether the functions is reachable from harness
    key1: value_description.
    """
    reachable: str = Field(
        default="No", description="""
        `Yes` or `No` to indicate whether the functions is reachable from the harness.
        """
    )
    reason: Optional[str] = Field(
        default=None, description="""
        The reason why the functions is reachable or not.
        If the functions is reachable, please explain why it is reachable.
        If the functions is not reachable, please explain why it is not reachable.
        """, Optional=True
    )

class SeedGeneratorAgent(BaseAgent):
    """
    This agent will follow the steps above.
    """
    current_dir = os.path.dirname(os.path.abspath(__file__))
    prompt_dir = os.path.join(current_dir, "prompts")
    _l.debug(f"llm folder is {prompt_dir}")
    system_prompt = os.path.join(prompt_dir, "ha.system.j2")
    user_prompt = os.path.join(prompt_dir, "ha.user.j2")

    __SYSTEM_PROMPT_TEMPLATE__ = system_prompt
    __USER_PROMPT_TEMPLATE__ = user_prompt
    __LLM_ARGS__ = {"temperature": 0,
                    "max_tokens": 8192}
    __RAISE_ON_BUDGET_EXCEPTION__ = True
    __RAISE_ON_RATE_LIMIT_EXCEPTION__ = True

    harness_code: Optional[str]
    source_and_traces: str
    jazzer_sanitizer_description: List
    pois_reason: Optional[str]
    fall_back_python_script: Path



    def get_step_input_vars(self, step: AgentPlanStep) -> dict:
        # Template variables for the prompts
        return dict(
            **super().get_step_input_vars(step),
            harness_code=self.harness_code,
            source_and_traces=self.source_and_traces,
            jazzer_sanitizer_description=self.jazzer_sanitizer_description,
            pois_reason=self.pois_reason
        )

    def on_step_success(self, step: AgentPlanStep, result):
        """
        This is just an example of how you could conditionally skip a step if you wanted.
        """
        remaining_steps = self.plan.steps[self.plan.current_step+1:]
        if step.name == "determine_reachibility":
            # assert isinstance(result, str)
            assert isinstance(result.reachable, str)
            if "No" in result.reachable:
                # Skip over the next step
                # Directly terminate the plan if the LLM think the harness cannot trigger the function. 
                # This will cause the list out of index error. Probably fine
                self.plan.current_step += (len(remaining_steps)-1)

        return super().on_step_success(step, result)

    def validate_step_result(
            self,
            step: AgentPlanStep,
            attempt: AgentPlanStepAttempt,
            result
    ) -> bool:
        # Here we can perform validation on the result of the step
        # If we return False, the agent will retry the step with our feedback

        # This first example will take the llm output and pass it into some other part
        # which uses that output and gives CriticFeedback
        if step.name == 'review_script':
            _l.debug(f"the script is {result}")
            assert (isinstance(result, str))
            res = self.validate_gen_scripts_result(result)
            if res.success:
                return True
            attempt.critic_review = res
            return False
        return super().validate_step_result(step, attempt, result)
