

import logging
import re
from agentlib import LocalObject, ObjectParser, Field, tools, LLMFunction
from agentlib import AgentWithHistory, LocalObject, ObjectParser, Field, tools
from agentlib.lib.common.parsers import BaseParser

from ..toolbox.peek_src import get_functions_by_file, show_file_at
from ..toolbox.code_ql_ops import CODEQL_TOOLS
from ..toolbox.peek_dbg import check_coverage_for, check_value_of_variable_at

from typing import Optional, Any

logger = logging.getLogger('ExploitDeveloperFromSarif')

def get_script():
    pass


class MyParser(BaseParser):
    # The model used to recover the format of the patch report
    recover_with = 'gpt-4o-mini'

    # This is the output format that describes the output of triageGuy
    __OUTPUT_DESCRIPTION = '/src/discoveryguy/prompts/ExploitDeveloperFromSarif/ExploitDeveloperFromSarif.output.txt'

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.exp_dev = kwargs.get('exp_dev')

    def get_format_instructions(self) -> str:
        # This string is used in the user prompt as {{output_format}}
        output_format = open(self.__OUTPUT_DESCRIPTION, 'r').read()
        current_language = self.exp_dev.LANGUAGE_EXPERTISE
        # Let's template the report example based on the current language
        patch_report_template = open(f'/src/discoveryguy/prompts/ExploitDeveloperFromSarif/extras-lang/exploits_reports/report.{current_language}', 'r').read()
        output_format = output_format.replace('<PLACEHOLDER_FOR_EXAMPLE_REPORTS_BY_LANGUAGE>', patch_report_template)
        return output_format

    def invoke(self, msg, *args, **kwargs) -> dict:
        return self.parse(msg['output'])

    def fix_format(self, text: str) -> str:
        fix_llm = LLMFunction.create(
            'Fix the format of the current report according to the format instructions.\n\n# CURRENT REPORT\n{{ info.current_report }}\n\n# OUTPUT FORMAT\n{{ info.output_format }}',
            model=self.recover_with,
            use_loggers=True,
            temperature=0.0,
            include_usage=True
        )
        fixed_text, usage = fix_llm(
            info = dict(
                current_report = text,
                output_format = self.get_format_instructions()
            )
        )

        return fixed_text

    def extract_exploit_dev_report(self, report:str) -> dict:
        exploit_script = re.search(r'<exploit_script>(.*?)</exploit_script>', report, re.DOTALL)
        if not exploit_script:
            raise Exception('No exploit_script found in the report!')
        exploit_script = exploit_script.group(1).strip() if exploit_script else None

        # Combine everything into a final dictionary
        exploit_dev_report = {
            "exploit_script": exploit_script
        }

        return exploit_dev_report

    def parse(self, text: str):
        try_itr = 1
        while try_itr <= 3:
            m = re.search(r'<report>([\s\S]*?)</report>', text)
            if m:
                try:
                    exploit_script = self.extract_exploit_dev_report(m.group(0))
                    logger.info(f'âœ… Regexp-Parser: Successfully parsed the exploit developer report from the output!')
                    return exploit_script
                except Exception as e:
                    logger.info(f'ðŸ¤¡ Regexp-Error: Error parsing the exploit developer report - {e}')
                    logger.info(f'ðŸ¤¡ Regexp-Error: Trying to fix the format of the exploit developer report... Attempt {try_itr}!')
                    text = self.fix_format(text)
            else:
                # Technically, this should never happen
                # the parser should make sure that the output is always in the format.
                logger.info(f'ðŸ¤¡ Regexp-Error: Could not parse the exploit developer report from the ouput!')
                logger.info(f'ðŸ¤¡ Regexp-Error: Trying to fix the format of the exploit developer report... Attempt {try_itr}!')
                text = self.fix_format(text)
            try_itr+=1

class ExploitDeveloperFromSarif(AgentWithHistory[dict, str]):
    __LLM_ARGS__ = {"temperature": 0}

    # Choose a language model to use (default gpt-4-turbo)
    #__LLM_MODEL__ = 'gpt-o1'
    #__LLM_MODEL__ = 'gpt-4o'
    #__LLM_MODEL__ = "claude-3.5-sonnet"
    __LLM_MODEL__ = "claude-3.7-sonnet"
    # __LLM_MODEL__ = "claude-3-opus"
    # __LLM_MODEL__ = "oai-gpt-o3-mini"
    #__LLM_MODEL__ = "claude-3.7-sonnet"

    __SYSTEM_PROMPT_TEMPLATE__ = "/src/discoveryguy/prompts/ExploitDeveloperFromSarif/system.j2"

    __USER_PROMPT_TEMPLATE__ = "/src/discoveryguy/prompts/ExploitDeveloperFromSarif/user.j2"

    __OUTPUT_PARSER__ = MyParser
    __MAX_TOOL_ITERATIONS__ = 30

    # __OUTPUT_PARSER__ = ObjectParser(CrashingScript, use_fallback=True,  use_structured_output=True)

    LANGUAGE_EXPERTISE: Optional[str]
    PROJECT_NAME: Optional[str]
    VULN_NAME: Optional[str]
    VULN_DESC: Optional[str]
    LOCS_IN_SCOPE: Optional[str] = None
    SINK_PATH: Optional[str] = None
    SINK_NAME: Optional[str] = None
    HARNESS_PATH: Optional[str] = None
    HARNESS_CODE: Optional[str]

    SCRIPT_FAILED: Optional[bool] = False
    ERROR_MSG: Optional[str] = None

    SINK_UNREACHABLE_FEEDBACK: Optional[str] = None
    BACKWARD_PATH: Optional[str] = None
    FORWARD_PATH: Optional[str] = None

    SINK_OK_NO_CRASH_FEEDBACK: Optional[str] = None

    LAST_SCRIPT: Optional[str] = None

    IS_EXTRA_FEEDBACK: Optional[bool] = False
    EXTRA_FEEDBACK: Optional[str] = None

    IS_DUPLICATE_SCRIPT: Optional[bool] = False

    __LOGGER__ = logging.getLogger("ExploitDeveloperFromSarif")
    __LOGGER__.setLevel(logging.ERROR)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.RUN_ID = kwargs.get("run_id")
        self.LANGUAGE_EXPERTISE = kwargs.get("language")
        self.PROJECT_NAME = kwargs.get("project_name")
        self.VULN_NAME = kwargs.get("vuln_name")
        self.VULN_DESC = kwargs.get("vuln_desc")
        self.HARNESS_PATH = kwargs.get("harness_path")
        self.HARNESS_CODE = kwargs.get("harness_code")
        self.SINK_PATH = kwargs.get("sink_path")
        self.SINK_NAME = kwargs.get("sink_name")

        self.with_codeql_server = kwargs.get('with_codeql_server', False)

        # Process the loc in scope and template the variable
        locs_in_scope = kwargs.get('locs_in_scope')
        _locs_in_scope_ = ""
        for loc in locs_in_scope:
            _locs_in_scope_ += f"- File: {loc.file} | Function: {loc.func} | Start Line: {loc.line}\n"
        self.LOCS_IN_SCOPE = _locs_in_scope_


    def get_input_vars(self, *args, **kw):
        vars = super().get_input_vars(*args, **kw)
        vars.update(
            RUN_ID=self.RUN_ID,
            LANGUAGE_EXPERTISE=self.LANGUAGE_EXPERTISE,
            PROJECT_NAME=self.PROJECT_NAME,
            VULN_NAME=self.VULN_NAME,
            VULN_DESC=self.VULN_DESC,
            SCRIPT_FAILED=self.SCRIPT_FAILED,
            ERROR_MSG=self.ERROR_MSG,
            SINK_UNREACHABLE_FEEDBACK=self.SINK_UNREACHABLE_FEEDBACK,
            SINK_OK_NO_CRASH_FEEDBACK=self.SINK_OK_NO_CRASH_FEEDBACK,
            BACKWARD_PATH=self.BACKWARD_PATH,
            FORWARD_PATH=self.FORWARD_PATH,
            HARNESS_CODE=self.HARNESS_CODE,
            HARNESS_PATH=self.HARNESS_PATH,
            SINK_PATH=self.SINK_PATH,
            SINK_NAME=self.SINK_NAME,
            LOCS_IN_SCOPE=self.LOCS_IN_SCOPE,
            IS_EXTRA_FEEDBACK=self.IS_EXTRA_FEEDBACK,
            EXTRA_FEEDBACK=self.EXTRA_FEEDBACK,
            LAST_SCRIPT=self.LAST_SCRIPT,
            IS_DUPLICATE_SCRIPT=self.IS_DUPLICATE_SCRIPT
        )
        return vars

    def get_available_tools(self):

        ALL_TOOLS = {
            "get_functions_by_file": get_functions_by_file,
            "show_file_at": show_file_at,
        }

        if self.with_codeql_server:
            ALL_TOOLS.extend(CODEQL_TOOLS.values())

        if self.SINK_OK_NO_CRASH_FEEDBACK:
            ALL_TOOLS["check_coverage_for"] = check_coverage_for
            #ALL_TOOLS["check_value_of_variable_at"] = check_value_of_variable_at

        return ALL_TOOLS.values()

    def reset_feedback(self):
        self.SINK_UNREACHABLE_FEEDBACK = None
        self.SINK_OK_NO_CRASH_FEEDBACK = None
        self.BACKWARD_PATH = None
        self.FORWARD_PATH = None
        self.IS_EXTRA_FEEDBACK = False
        self.EXTRA_FEEDBACK = None
        self.IS_DUPLICATE_SCRIPT = False
        self.LAST_SCRIPT = None

    def set_sink_unreachable(self, feedback):
        self.SINK_UNREACHABLE_FEEDBACK = feedback

    def set_sink_reachable_no_crash_feedback(self, feedback):
        self.SINK_OK_NO_CRASH_FEEDBACK = feedback

    def set_extra_feedback(self, b, message=None):
        self.IS_EXTRA_FEEDBACK = b
        self.EXTRA_FEEDBACK = message

    def set_frontier_feedback(self, backward_str=None, forward_str=None):
        self.BACKWARD_PATH = backward_str
        self.FORWARD_PATH = forward_str

    def set_duplicate_script(self, b):
        self.IS_DUPLICATE_SCRIPT = b

    def set_last_script(self, script_content):
        self.LAST_SCRIPT = script_content

    def script_failed(self, b, error_msg=None):
        self.SCRIPT_FAILED = b
        self.ERROR_MSG = error_msg

    def increase_temperature_by(self, value: float):
        current_temperatue = self.__LLM_ARGS__.get('temperature', 0.0)
        new_temperature = current_temperatue + value
        # The temperature should be between 0.0 and 1.0
        new_temperature = max(0.0, min(1.0, new_temperature))
        print(f'ðŸ”¥ðŸ”¥ðŸ”¥ ExploitDeveloperFromSarif is heating up... ({current_temperatue} -> {new_temperature}) ðŸ”¥ðŸ”¥ðŸ”¥')
        # Update the temperature
        ExploitDeveloperFromSarif.__LLM_ARGS__ = {"temperature": new_temperature}

    def decrease_temperature_by(self, value: float):
        current_temperatue = self.__LLM_ARGS__.get('temperature', 0.0)
        new_temperature = current_temperatue - value
        # The temperature should be between 0.0 and 1.0
        new_temperature = max(0.0, min(1.0, new_temperature))
        print(f'ðŸ¥¶ðŸ¥¶ðŸ¥¶ ExploitDeveloperFromSarif is cooling down... ({current_temperatue} -> {new_temperature}) ðŸ¥¶ðŸ¥¶ðŸ¥¶')
        # Update the temperature
        ExploitDeveloperFromSarif.__LLM_ARGS__ = {"temperature": new_temperature}

    def get_output_parser(self):
        return MyParser(exp_dev=self)