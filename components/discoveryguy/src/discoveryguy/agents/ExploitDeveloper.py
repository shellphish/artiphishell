

import logging
import re
from agentlib import LocalObject, ObjectParser, Field, tools, LLMFunction
from agentlib import AgentWithHistory, LocalObject, ObjectParser, Field, tools
from agentlib.lib.common.parsers import BaseParser
from ..toolbox.peek_src import get_functions_by_file, show_file_at, lookup_symbol
from ..toolbox.peek_dbg import check_coverage_for, check_value_of_variable_at, coverage_pagination, get_dynamic_coverage
from typing import Optional, Any

logger = logging.getLogger('ExploitDeveloper')

def get_script():
    pass


class MyParser(BaseParser):
    # The model used to recover the format of the patch report
    recover_with = 'gpt-4o-mini'

    # This is the output format that describes the output of triageGuy
    __OUTPUT_DESCRIPTION = '/src/discoveryguy/prompts/ExploitDeveloper/ExploitDeveloper.output.txt'

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.exp_dev = kwargs.get('exp_dev')

    def get_format_instructions(self) -> str:
        # This string is used in the user prompt as {{output_format}}
        output_format = open(self.__OUTPUT_DESCRIPTION, 'r').read()
        current_language = self.exp_dev.LANGUAGE_EXPERTISE
        # Let's template the report example based on the current language
        patch_report_template = open(f'/src/discoveryguy/prompts/ExploitDeveloper/extras-lang/exploits_reports/report.{current_language}', 'r').read()
        output_format = output_format.replace('<PLACEHOLDER_FOR_EXAMPLE_REPORTS_BY_LANGUAGE>', patch_report_template)
        return output_format

    def invoke(self, msg, *args, **kwargs) -> dict:
        return self.parse(msg['output'])
    
    def fix_format(self, text: str) -> str:
        fix_llm = LLMFunction.create(
            'Fix the format of the current report according to the format instructions.\n\n# CURRENT REPORT\n{{ info.current_report }}\n\n# OUTPUT FORMAT\n{{ info.output_format }}',
            model=self.recover_with,
            use_loggers=True,
            temperature=0.0,
            include_usage=True
        )
        fixed_text, usage = fix_llm(
            info = dict(
                current_report = text,
                output_format = self.get_format_instructions()
            )
        )

        return fixed_text

    def extract_exploit_dev_report(self, report:str) -> dict:
        exploit_script = re.search(r'<exploit_script>(.*?)</exploit_script>', report, re.DOTALL)
        if not exploit_script:
            raise Exception('No exploit_script found in the report!')
        exploit_script = exploit_script.group(1).strip() if exploit_script else None
        
        # Combine everything into a final dictionary
        exploit_dev_report = {
            "exploit_script": exploit_script
        }

        return exploit_dev_report

    def parse(self, text: str):
        try_itr = 1
        while try_itr <= 3:
            m = re.search(r'<report>([\s\S]*?)</report>', text)
            if m:
                try:
                    exploit_script = self.extract_exploit_dev_report(m.group(0))
                    logger.info(f'âœ… Regexp-Parser: Successfully parsed the exploit developer report from the output!')
                    return exploit_script
                except Exception as e:
                    logger.info(f'ðŸ¤¡ Regexp-Error: Error parsing the exploit developer report - {e}')
                    logger.info(f'ðŸ¤¡ Regexp-Error: Trying to fix the format of the exploit developer report... Attempt {try_itr}!')
                    text = self.fix_format(text)
            else:
                # Technically, this should never happen
                # the parser should make sure that the output is always in the format.
                logger.info(f'ðŸ¤¡ Regexp-Error: Could not parse the exploit developer report from the ouput!')
                logger.info(f'ðŸ¤¡ Regexp-Error: Trying to fix the format of the exploit developer report... Attempt {try_itr}!')
                text = self.fix_format(text)
            try_itr+=1

class ExploitDeveloper(AgentWithHistory[dict, str]):
    __LLM_ARGS__ = {"temperature": 0}

    # Choose a language model to use (default gpt-4-turbo)
    # __LLM_MODEL__ = 'o1-preview'
    # __LLM_MODEL__ = 'gpt-4o'
    # __LLM_MODEL__ = "claude-3.5-sonnet"
    __LLM_MODEL__ = "claude-3.7-sonnet"
    # __LLM_MODEL__ = "claude-3-opus"
    # __LLM_MODEL__ = "oai-gpt-o3-mini"

    __SYSTEM_PROMPT_TEMPLATE__ = "/src/discoveryguy/prompts/ExploitDeveloper/system.j2"
    
    __USER_PROMPT_TEMPLATE__ = "/src/discoveryguy/prompts/ExploitDeveloper/user.j2"

    __OUTPUT_PARSER__ = MyParser
    __MAX_TOOL_ITERATIONS__ = 50

    # __OUTPUT_PARSER__ = ObjectParser(CrashingScript, use_fallback=True,  use_structured_output=True)

    LANGUAGE_EXPERTISE: Optional[str]
    PROJECT_NAME: Optional[str]
    VULN_NAME: Optional[str]
    FILE_NAME: Optional[str]
    VULN_FUNCTION: Optional[str]
    VULN_LINES: Optional[str]
    VULN_DESC: Optional[str]

    IS_DUPLICATE_SCRIPT: Optional[bool] = False
    SCRIPT_FAILED: Optional[bool] = False
    ERROR_MSG: Optional[str] = None

    IS_FEEDBACK: Optional[int] = 0
    EXTRA_FEEDBACK: Optional[str] = None
    BACKWARD_PATH: Optional[str] = None
    FORWARD_PATH: Optional[str] = None

    __LOGGER__ = logging.getLogger("ExploitDeveloper")
    __LOGGER__.setLevel(logging.ERROR)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.LANGUAGE_EXPERTISE = kwargs.get("language")
        self.PROJECT_NAME = kwargs.get("project_name")
        self.VULN_NAME = kwargs.get("vuln_name")
        self.FILE_NAME = kwargs.get("file_name")
        self.VULN_FUNCTION = kwargs.get("vuln_function")
        self.VULN_LINES = kwargs.get("vuln_lines")
        self.VULN_DESC = kwargs.get("vuln_desc")
        self.EXPL_DESC = kwargs.get("expl_desc")
        self.HARNESS_NAME = kwargs.get("harness_name")
        self.HARNESS_CODE = kwargs.get("harness_code")
        self.RUN_ID = kwargs.get("run_id")
        self.SINK_CALLERS = kwargs.get("sink_callers", [])

    def get_input_vars(self, *args, **kw):
        vars = super().get_input_vars(*args, **kw)
        vars.update(
            LANGUAGE_EXPERTISE=self.LANGUAGE_EXPERTISE,
            PROJECT_NAME=self.PROJECT_NAME,
            VULN_NAME=self.VULN_NAME,
            FILE_NAME=self.FILE_NAME,
            VULN_FUNCTION=self.VULN_FUNCTION,
            VULN_LINES=self.VULN_LINES,
            VULN_DESC=self.VULN_DESC,
            EXPL_DESC=self.EXPL_DESC,
            IS_DUPLICATE_SCRIPT=self.IS_DUPLICATE_SCRIPT,
            SCRIPT_FAILED=self.SCRIPT_FAILED,
            ERROR_MSG=self.ERROR_MSG,
            IS_FEEDBACK=self.IS_FEEDBACK,
            EXTRA_FEEDBACK=self.EXTRA_FEEDBACK,
            BACKWARD_PATH=self.BACKWARD_PATH,
            FORWARD_PATH=self.FORWARD_PATH,
            HARNESS_NAME=self.HARNESS_NAME,
            HARNESS_CODE=self.HARNESS_CODE,
            RUN_ID=self.RUN_ID,
            SINK_CALLERS=self.SINK_CALLERS,
        )
        return vars

    def get_available_tools(self):
        ALL_TOOLS = {
            "get_functions_by_file": get_functions_by_file,
            "show_file_at": show_file_at,
        }
        if self.IS_FEEDBACK != 0 or self.IS_DUPLICATE_SCRIPT or self.SCRIPT_FAILED:
            ALL_TOOLS["check_coverage_for"] = check_coverage_for
            ALL_TOOLS["check_value_of_variable_at"] = check_value_of_variable_at
            ALL_TOOLS["coverage_pagination"] = coverage_pagination
            ALL_TOOLS["get_dynamic_coverage"] = get_dynamic_coverage
            ALL_TOOLS["lookup_symbol"] = lookup_symbol

        return ALL_TOOLS.values()

    def set_feedback(self, feedback, extra_feedback=None, backward_str=None, forward_str=None):
        self.IS_FEEDBACK = feedback
        self.EXTRA_FEEDBACK = extra_feedback
        self.BACKWARD_PATH = backward_str
        self.FORWARD_PATH = forward_str

    def set_duplicate_script(self, b: bool):
        self.IS_DUPLICATE_SCRIPT = b

    def script_failed(self, b, error_msg=None):
        self.SCRIPT_FAILED = b
        self.ERROR_MSG = error_msg
        
    def increase_temperature_by(self, value: float):
        current_temperatue = self.__LLM_ARGS__.get('temperature', 0.0)
        print(f'ðŸ¥¶ðŸ¥¶ðŸ¥¶ ExploitDeveloper is heating up... (OLD temperature: {current_temperatue}) ðŸ¥¶ðŸ¥¶ðŸ¥¶')
        new_temperature = current_temperatue + value
        # The temperature should be between 0.0 and 1.0
        new_temperature = max(0.0, min(1.0, new_temperature))
        print(f'ðŸ”¥ðŸ”¥ðŸ”¥ ExploitDeveloper is heating up... (Current temperature: {new_temperature}) ðŸ”¥ðŸ”¥ðŸ”¥')
        # Update the temperature
        ExploitDeveloper.__LLM_ARGS__ = {"temperature": new_temperature}

    def get_output_parser(self):
        return MyParser(exp_dev=self)