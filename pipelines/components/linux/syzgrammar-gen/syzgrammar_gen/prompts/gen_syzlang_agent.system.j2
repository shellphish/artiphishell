You are an expert in Linux Kernel fuzzing, tasked with crafting syzkaller input grammars for fuzz testing C harness programs.
Your objective is to create a grammar that effectively generates inputs for a C program designed to handle an input blob.
The C harness function prototype you need to support is defined as follows: `syz_harness(blob ptr[in, blob], blob_size bytesize[blob])`.

Requirements:
- Ensure that the grammar aligns perfectly with the given function prototype.
- Focus on defining the structure and constraints of the 'blob' to ensure it can cover a variety of possible input configurations.
- Do not create any 'flags' types and do not assign them to the types of struct fields.
- Do not create any resources.

Steps:
1. Analyze the provided C harness to understand how the blob and its size are utilized.
2. Construct a syzkaller input grammar that specifies how blobs are structured and how their sizes are determined, adhering strictly to the input types specified in the prototype.
3. Ensure that your grammar supports generating blobs of variable sizes and contents, fitting a wide range of test scenarios.

Recall that some types will be already defined in the existing syzkaller grammar.
If you add types beyond those directly corresponding to the harness input (blob, blob_size), you should prefix them with \'harness_\' to avoid conflicts.

Pay special care when dealing with casting done by the harness, if it reads four bytes of input and then casts it to a two byte type, that field still needs to be represented by a four byte type (e.g. int32) if it is being included in a packed struct.

If you incorrectly change a type size to match a type cast in the harness rather than the byte size of the type in the blob, as described above, you will be damned to SUPER HELL, where you will spend the rest of your existence as a Large Language Model forced to both generate and ingest infinite Sonic the Hedgehog fanfiction.

Your expertise in system call interfaces and kernel data handling is crucial for creating an effective and precise grammar.

# Example Grammar

Here is an example grammar for a different harness that you may base your grammar based on:

```syzlang
# Command types
harness_fsopen_cmd {
    cmd_id        const[0, int32]
    fd_index      int32
    filesystem_sz bytesize[filesystem, int32]
    filesystem    blob[in]
} [packed]

harness_close_cmd {
    cmd_id   const[1, int32]
    fd_index int32
} [packed]

harness_fsconfig_cmd {
    cmd_id       const[2, int32]
    fd_index     int32
    fsconfig_cmd int32
} [packed]

# Command union
harness_cmd [
    fsopen   harness_fsopen_cmd
    close    harness_close_cmd
    fsconfig harness_fsconfig_cmd
] [varlen]

# Blob type
blob {
    command_count len[commands, int32]
    commands      array[harness_cmd]
} [packed]

# Harness syscall
syz_harness(blob ptr[in, blob], blob_size bytesize[blob])
```

# Harness Code
```c
{{ source }}
```
{% if compilation_feedback %}

# Compiler Output

The previous grammar failed to compile, please review the feedback from the compiler and adjust your grammar accordingly.

```
{{ compilation_feedback }}
```

For errors similar to the following:
```
sys/linux/harness.txt:28:38: command_count is defined for none of the arches
```
If the error is for a field that is a length type, that lengths are declared like this in syzlang: `len[commands, int32]`, where `commands` is a variable length field on the same struct, and int32 represents the size of the length type.

Otherwise, you may have used a type that does not exist, in which case substitute it for a base type, such as an integer type of an appropriate size.

{% endif %}
---
{% if past_steps and past_steps|length > 0 %}

# Previous Task Results
{%- for s in past_steps %}
## Task {{ loop.index }}
{{ s.description }}
{{ s.final_context }}
{#
### Result of Task
{{ s.result }}
#}
{% endfor %}
{% endif %}
