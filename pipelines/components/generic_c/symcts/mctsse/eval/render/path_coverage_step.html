<!DOCTYPE html PUBLIC"-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
</head>

<!-- Load c3.css -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.7.20/c3.min.css" integrity="sha512-cznfNokevSG7QPA5dZepud8taylLdvgr0lDqw/FEZIhluFsSwyvS81CMnRdrNSKwbsmc43LtRd2/WMQV+Z85AQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />

<!-- Load d3.js and c3.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js" integrity="sha512-FHsFVKQ/T1KWJDGSbrUhTJyS1ph3eRrxI228ND0EGaEp6v4a/vGwPWd3Dtd/+9cI7ccofZvl/wulICEurHN1pg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.7.20/c3.min.js" integrity="sha512-+IpCthlNahOuERYUSnKFjzjdKXIbJ/7Dd6xvUp+7bEw0Jp2dg6tluyxLs+zq9BMzZgrLv8886T4cBSqnKiVgUw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<body>
    <input type="file" id="file-input" accept=".json,text/json"/>
    <select id="node-selector" onChange="this.blur()"></select>

    <label for="show-grid">Show Grid?</label>
    <label class="switch">
        <input id="show-grid" type="checkbox">
        <span class="slider round"></span>
    </label>

    <label for="log-scale">Log Scale?</label>
    <label class="switch">
        <input id="log-scale" type="checkbox">
        <span class="slider round"></span>
    </label>
    <button id="render-button">Render</button>

    <div id="data"></div>

    <br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
    <br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>
</body>
<script>

function update_dropdown(node_names) {
    let node_selector = document.querySelector("#node-selector");
    let value = node_selector.value || node_names[0];

    options = node_names.map((name) => {
        let opt = document.createElement("option");
        opt.value = name;
        opt.text = name;
        return opt;
    })
    node_selector.replaceChildren(...options);
    node_selector.value = value;
}
// function update_chart(key, counts) {
//     // Preprocessing
//     let num_branches_shown = +document.querySelector("#branches-shown").value;
//     let branches_offset = +document.querySelector("#branches-offset").value;
//     let subsample = +document.querySelector("#subsample").value;
//     let {header, cols_by_node} = transform_counts_into_columns(counts, key);
//     let mult = key.includes('percents') ? 1 : 2;
//     for (node_name in cols_by_node) {
//         cols_by_node[node_name] = cols_by_node[node_name]
//                                     .slice(branches_offset * mult)
//                                     .slice(
//                                         0,
//                                         mult * num_branches_shown
//                                     )
//                                     .map((column, idx) => {
//                                         var result = [column[0]]; // skip the branch id
//                                         for(var i = 1; i < column.length; i += subsample)
//                                         {
//                                             result.push(column.slice(i, i+subsample).reduce((prev, curr) => prev + curr) / (key.includes('percents') ? subsample : 1));
//                                         }
//                                         return result;
//                                     });
//     }

//     // Plotting
//     let selected_node = document.querySelector('#node-selector').value || 'master';
//     let show_grid = document.querySelector('#show-grid').checked;
//     var columns = cols_by_node[selected_node]
//     if (document.querySelector('#log-scale').checked)
//     {
//         columns = columns.map(column => column.map((count, count_idx) => {
//                 return !count_idx || count <= 1 ? count : 1 + Math.log2(count)
//             })
//         );
//     }
//     let searchExpr = document.querySelector("#filter").value;
//     if (searchExpr)
//     {
//         columns = columns.filter(column => {
//             let [idx,...counts] = column;
//             idx = +idx;
//             return eval(searchExpr);
//         });
//     }
//     let chart = c3.generate({
//         bindto: '#chart_' + key,
//         title: {
//             text: key,
//         },
//         size: {
//             height: 480,
//         },
//         data: {
//             x: 'x',
//             columns: [header, ...columns]
//         },
//         subchart: {
//             show: true
//         },
//         grid: {
//             x: {
//                 show: show_grid
//             },
//             y: {
//                 show: show_grid
//             }
//         },
//         legend: {
//             show: false
//         }
//     })
// }
function range(size, startAt = 0) {
    return [...Array(size).keys()].map(i => i + startAt);
}
function repeat(value, size) {
    return [...Array(size).keys()].map(v => value);
}

function selected_node() {
    let sel = document.querySelector('#node-selector').value || 'master';
    return sel;
}

function extract_metadata(cov) {
    var paths_for_branch = new Map();
    Object.entries(cov).forEach( ([ node_name, paths_by_branch]) => {
        Object.entries(paths_by_branch).forEach( ([branch_id, path_counts]) => {
            if (!paths_for_branch.has(branch_id)) {
                paths_for_branch.set(branch_id, new Set());
            }
            let v = paths_for_branch.get(branch_id);
            Object.entries(path_counts).forEach( ([path_id, count]) => {
                v.add(path_id);
            })
        });
    });
    return {paths_for_branch};
}
function normalize_data (cov) {
    /*
     * This formats the data into a 4-deep set mapping
     *   node_name => (timestep => (branch => (path_id => count)))
     */
    let {paths_for_branch} = extract_metadata(cov);

    let by_node/** @type {Map<String, Map<String, Map<String, int>>>}*/ = new Map();
    Object.keys(cov).forEach( (node_name) => {
        let by_branch = new Map();
        by_node.set(node_name, by_branch);
        paths_for_branch.forEach( (paths_set, branch_id) => {
            let by_path = new Map();
            by_branch.set(branch_id, by_path);
            paths_set.forEach( (path_id) => {
                let cov_by_branch = cov[node_name] || {};
                let cov_by_path = cov_by_branch[branch_id] || {};
                let cov_count = cov_by_path[path_id] || 0;
                by_path.set(path_id, cov_count);
            })
        })
    })
    return by_node;
}
function get_data_columns(/** @type {Map<String, Map<String, int>>}*/ cov) {
    // cov is branch_id => {path_id => count}}
    const MAX = 40;
    let max_num_paths = Math.min(MAX, Object.entries(cov)
        .map(([_, path_counts]) => Object.keys(path_counts).length)
         .reduce((prev, cur) => Math.max(+prev, +cur), 0));

    let result = [];
    let max_num_branches = Math.min(MAX, Object.keys(cov).length);
    // let header = ['x'];
    // Object.keys(cov).slice(0, MAX).forEach(([branch_id, _], branch_index) => {
    //     header.push(branch_id);
    // })
    // result.push(header)
    for (i in range(max_num_paths)) {
        let arr = repeat(0, max_num_branches);
        arr.unshift("#"+(+i+1));
        result.push(arr);
    }
    Object.entries(cov).slice(0, MAX).forEach(([branch_id, path_counts], branch_index) => {
        path_counts = Object.entries(path_counts);
        path_counts.sort(([a,a_count], [b, b_count]) => (b_count - a_count));
        path_counts.slice(0, max_num_paths).forEach(([path_id, path_count], path_sorted_index) => {
            result[path_sorted_index][branch_index+1] = path_count;
        })
    })
    return result;

    // return [
    //     ['path_0', null, null, null, null, null, null, null, null,   11, null, null, null],
    //     ['path_1', null, null, null, null, null, null, null, null,   12, null, null, null],
    //     ['path_2',    1, null, null, null, null, null, null, null, null, null, null, null],
    //     ['path_3',    3, null, null, null, null, null, null, null, null, null, null, null],
    //     ['path_4',    3, null, null,    1, null, null,    1, null, null, null, null, null],
    // ]
}
function plot_cov(element, node_name, cov) {
    // Now the data is {node_name => {branch_id => {path_id => count}}} with all `Map`s, except for count of course
    //let /** @type {Map<String, Map<String, Map<String, int>>>}*/ normalized = normalize_data(cov);

    let columns = get_data_columns(cov[node_name]);
    // to do this in column format,
    let chart = c3.generate({
        bindto: element,
        title: {
            text: node_name,
        },
        size: {
            height: 480,
        },
        data: {
            columns: columns,
            type: 'bar',
            // line: {
            //     connectNull: true,
            // },
        },
        grid: {
            x: {
                show: true
            },
            y: {
                show: true
            }
        },
    })
}
function render() {
    if (!data || !node_names) return;
    let data_node = document.querySelector("#data");
    data_node.innerHTML = "";
    let data_elem = document.createElement("div");
    data_node.appendChild(data_elem);

    let node = selected_node();
    plot_cov(data_elem, node, data);
}
function load_coverage(file) {
    let reader = new FileReader();
    reader.addEventListener('load', function(e) {
            let text = e.target.result;
            let loaded = text.split('\n').filter(l => l).map(x => {
                return JSON.parse(x);
            });
            [data] = loaded;
            node_names = Object.keys(data);
            const counts_loaded = new CustomEvent('counts_loaded', {detail: {node_names, data}});
            file_input.dispatchEvent(counts_loaded)
    });
    reader.readAsText(file);
}

var node_names = undefined;
var data = undefined;

let file_input = document.querySelector("#file-input");
if (file_input.files[0]) {
    load_coverage(file_input.files[0]);
}
file_input.addEventListener('change', () => {
    let file = file_input.files[0];
    load_coverage(file);
});

file_input.addEventListener('counts_loaded', (e) => {
    update_dropdown(e.detail.node_names);
})
document.querySelector("#render-button").addEventListener('click', (e) => render());
document.onkeyup = (e) => {
    if (e.code == 'Enter'){
        render();
        return false;
    }
}

</script>



<!-- Thanks https://www.w3schools.com/howto/howto_css_switch.asp -->
<style>
    /* The switch - the box around the slider */
    .switch {
     position: relative;
     display: inline-block;
     width: 32px;
     height: 18px;
   }

   /* Hide default HTML checkbox */
   .switch input {
     opacity: 0;
     width: 0;
     height: 0;
   }

   /* The slider */
   .slider {
     position: absolute;
     cursor: pointer;
     top: 0;
     left: 0;
     right: 0;
     bottom: 0;
     background-color: #ccc;
     -webkit-transition: .4s;
     transition: .4s;
   }

   .slider:before {
     position: absolute;
     content: "";
     height: 14px;
     width: 14px;
     left: 2px;
     bottom: 2px;
     background-color: white;
     -webkit-transition: .4s;
     transition: .4s;
   }

   input:checked + .slider {
     background-color: #2196F3;
   }

   input:focus + .slider {
     box-shadow: 0 0 1px #2196F3;
   }

   input:checked + .slider:before {
     -webkit-transform: translateX(14px);
     -ms-transform: translateX(14px);
     transform: translateX(14px);
   }

   /* Rounded sliders */
   .slider.round {
     border-radius: 17px;
   }

   .slider.round:before {
     border-radius: 50%;
   }
   </style>
</html>