# This is to parser ASAN report generated by syzkaller
# Ouput a yaml file that has each function on strack trace as a pois with
# 1. Relative file path
# 2. Function name
# 3. Line number
# Also we will filter out syzkaller functions
# We will use ASAN report title as sanitizer string

# The ouput yaml file will have the structure
# sanitizer_string:
# pois:
#   function_name:
#   relative_file_path:
#   line_number:

from pathlib import Path
from typing import List, Optional
import sys
import re
import argparse
import sys
import logging

import yaml

from patchery.code_parsing.code_parser import CodeParser

_l = logging.getLogger(__name__)


class AsanParser:
    def __init__(self, asan_report: str) -> None:
        self.report = asan_report

    # FIXME: There are reports that not match this pattern
    def extract_sanitizer_string(self) -> None:
        asan_data = self.report
        asan_data.replace("\\n", "\n")
        asan_data = asan_data.split("\n")

        error_pattern = re.compile(r"==\d+==ERROR: (.*?) on .*")

        # Iterate over the set of strings and search for the pattern
        sanitizer_string = None
        for line in asan_data:
            match = error_pattern.search(line)
            if match:
                sanitizer_string = match.group(1)
                break

        if not sanitizer_string:
            sys.exit(f"Error: error not found in the provided report. Are you sure this is an ASAN report")
        return sanitizer_string

    def extract_function_info(self) -> List[dict]:
        call_trace_found = False
        pois = []
        asan_data = self.report.replace("\\n", "\n")
        asan_data = asan_data.split("\n")
        trace_pattern = re.compile(r"^#\d+")
        irrelavant_pattern = re.compile(r"llvm|libc\.so|fuzzer|fuzz", re.IGNORECASE)
        for line in asan_data:
            line = line.strip()
            if trace_pattern.match(line) and not irrelavant_pattern.search(line):
                line_split = line.split(" ")
                function_name = line_split[3]
                path_and_number = line_split[-1]
                if "libsanitizer" in line:
                    continue
                if ":" in path_and_number:
                    pn_split = path_and_number.split(":")
                    relative_file_path = pn_split[0]
                    line_number = pn_split[-2]
                else:
                    pn_split = path_and_number.split("+")
                    relative_file_path = pn_split[0].replace("(", "")
                    if not any(ext in relative_file_path for ext in CodeParser.LANG_SUFFIXS):
                        _l.warning(f"The filepath of the POI contains no known language, assuming C")
                        relative_file_path += ".c"

                    line_number = 0

                # this is some hacked shit that should never have to run, but hey, we try to get rid of fuckups
                # on other people's parts
                tmp_start = "/tmp"
                for i in range(10):
                    if relative_file_path.startswith(tmp_start):
                        relative_file_path = relative_file_path.replace(tmp_start, "")
                        break
                    if i == 0:
                        tmp_start = "../" + tmp_start[1:]
                    else:
                        tmp_start = "../" + tmp_start

                pois.append(
                    {"function": function_name, "relative_file_path": relative_file_path, "line_number": line_number}
                )

        return pois

    @classmethod
    def parse_asan_report(cls, asan_report_path: Path, dst: Path) -> None:
        with open(asan_report_path, "r") as fp:
            asan_report = fp.read()

        aparser = cls(asan_report)
        # FIXME: sanitizer string extraction is wrong
        sanitizer_string = aparser.extract_sanitizer_string()
        pois = aparser.extract_function_info()
        asan_info = {
            "harness_id": "id_1",  # We assume for oss-fuzz target the harness_id always id_1
            "sanitizer_string": sanitizer_string,
            "pois": pois,
        }
        return asan_info
