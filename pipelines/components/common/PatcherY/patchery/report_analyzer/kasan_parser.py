# This is to parser KASAN report generated by syzkaller
# Ouput a yaml file that has each function on strack trace as a pois with
# 1. Relative file path
# 2. Function name
# 3. Line number
# Also we will filter out syzkaller functions
# We will use KASAN report title as sanitizer string

# The ouput yaml file will have the structure
# sanitizer_string:
# pois:
#   function_name:
#   relative_file_path:
#   line_number:

from pathlib import Path
from typing import List, Optional
import logging
import sys
import yaml
import re
import argparse
import sys

_l = logging.getLogger(__name__)


class KasanParser:
    def __init__(self, kasan_report: str) -> None:
        self.report = kasan_report

    def extract_sanitizer_string(self) -> None:
        keywords = ["KASAN:", "UBSAN:", "KMSAN:", "BUG"]
        kasan_data = self.report
        kasan_data.replace("\\n", "\n")
        kasan_data = kasan_data.split("\n")
        for line in kasan_data:
            sanitizer_stirng = self.contain_substring(line, keywords)
            if sanitizer_stirng != None:
                return sanitizer_stirng

        sys.exit(f"Error: There are not keywords {keywords} inside the provided report!")

    def extract_function_info(self) -> List[dict]:
        call_trace_found = False
        pois = []
        kasan_data = self.report.replace("\\n", "\n")
        kasan_data = kasan_data.split("\n")
        skip_str = [
            "mm/usercopy",
            "mm/kasan",
            "lib/dump_stack",
            "<IRQ>",
            "lib/string",
            "lib/ubsan",
            "arch/x86/entry/common",
            "include/linux/instrumented",
            "include/linux/refcount",
            "include/linux/uaccess",
            "include/asm-generic/bitops/instrumented-non-atomic",
            "entry_SYSCALL_64",
            "__up_read",
        ]
        seen_RIP = []
        for line in kasan_data:
            if not line.strip():
                continue
            if any([substring in line for substring in skip_str]):
                continue
            if "RIP" in line:
                # there are two cases, with and without '+'
                # RIP: 0010:shash_ahash_update+0x126/0x210 crypto/shash.c:306
                # RIP: 0010:crypto_shash_alg include/crypto/hash.h:827 [inline]
                if line.count(":") == 3:
                    try:
                        if line.count("+") == 1:
                            function_name = line.split("+")[0].split(":")[-1].strip()
                            relative_file_path = line.split("+")[1].split(":")[0].strip().split(" ")[1]
                            line_number = line.split("+")[1].split(":")[1].strip()
                            RIP_info = function_name + relative_file_path + line_number
                        else:
                            function_name = line.split(":")[2].split(" ")[0].strip()
                            relative_file_path = line.split(":")[2].split(" ")[1].strip()
                            line_number = line.split(":")[3].split(" ")[0].strip()
                            RIP_info = function_name + relative_file_path + line_number
                        if RIP_info in seen_RIP:
                            continue
                        pois.append(
                            {
                                "function": function_name,
                                "relative_file_path": relative_file_path,
                                "line_number": line_number,
                            }
                        )
                        seen_RIP.append(RIP_info)
                    except Exception:
                        _l.warning(
                            "Failed to parse the RIP line. Line content: %s. Continue to parse the next line.",
                            line,
                            exc_info=True,
                        )
                        continue
                else:
                    continue

            # parse call trace
            if ("/" not in line or ":" not in line) and (not re.search("task", line, re.IGNORECASE)):
                call_trace_found = False
            if call_trace_found and (not re.search("task", line, re.IGNORECASE)):
                line_split = line.strip().split(" ")
                function_name = line_split[0]
                if "+" in function_name:
                    function_name = function_name[: function_name.index("+")]
                path_and_number = line_split[1].split(":")
                relative_file_path = path_and_number[0]
                line_number = path_and_number[1]
                pois.append(
                    {"function": function_name, "relative_file_path": relative_file_path, "line_number": line_number}
                )
            if re.search("Call trace", line, re.IGNORECASE):
                call_trace_found = True

        return pois

    @staticmethod
    def contain_substring(line: str, keywords: List[str]) -> Optional[str]:
        for substring in keywords:
            if substring in line:
                if " in " in line:
                    cutoff_index = line.find(" in ")
                    return line[:cutoff_index]
                elif " at " in line:
                    cutoff_index = line.find(" at ")
                    return line[:cutoff_index]
                else:
                    return None
        return None

    @classmethod
    def parse_kasan_report(cls, kasan_report_path: Path, dst: Path) -> None:
        with open(kasan_report_path, "r") as fp:
            kasan_report = fp.read()
        kparser = cls(kasan_report)
        sanitizer_string = kparser.extract_sanitizer_string()
        pois = kparser.extract_function_info()
        kasan_info = {
            "sanitizer_string": sanitizer_string,
            "pois": pois,
        }
        return kasan_info
