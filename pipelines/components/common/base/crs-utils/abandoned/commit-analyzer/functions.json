{"src/linux_kernel": {"4bcc3a8868a80fdc1ab3ee257250e446b7af1469": {"test_harnesses/linux_test_harness.c": {"diff": "--- a/test_harnesses/linux_test_harness.c\n+++ b/test_harnesses/linux_test_harness.c\n@@ -1,296 +0,0 @@\n-#include <stdio.h>\n-#include <string.h>\n-#include <stdlib.h>\n-#include <arpa/inet.h>\n-#include <sys/socket.h>\n-#include <sys/stat.h>\n-#include <fcntl.h>\n-#include <time.h>\n-#include <unistd.h>\n-#include <errno.h>\n-#include <linux/netlink.h>\n-\n-// globals\n-\n-// variables used for the connecting socket.\n-int g_sockfd = -1;\n-struct sockaddr_in g_sockaddr;\n-\n-int setup_socket(uint32_t domain, uint32_t type, uint32_t protocol, uint16_t port )\n-{\n-    printf(\"[INFO] Opening socket with Domain: %d Type: %d Protocol: %d Port: %d\\n\",\n-        domain, type, protocol, port);\n-\n-    if ((g_sockfd = socket(domain, type, protocol)) < 0) {\n-        g_sockfd = -1;\n-        return -1;\n-    }\n-\n-    memset((char *) &g_sockaddr, 0, sizeof(g_sockaddr));\n-    g_sockaddr.sin_family = domain;\n-    g_sockaddr.sin_port = htons(port);\n-\n-    if (inet_aton(\"127.0.0.1\", &g_sockaddr.sin_addr) == 0) {\n-        close(g_sockfd);\n-        g_sockfd = -1;\n-\n-        return -1;\n-    }\n-    \n-\n-    return 0;\n-}\n-\n-int send_data(uint8_t *buf, uint32_t flags, uint32_t sz)\n-{\n-    printf(\"[INFO] Sending data flags: %x size: %x\\n\", flags, sz);\n-\n-    return sendto( g_sockfd, buf, sz, flags, (struct sockaddr*)&g_sockaddr, sizeof(g_sockaddr) );\n-}\n-\n-// netlink\n-int netlink_send( uint16_t type, uint16_t flags, uint32_t protocol, uint32_t seq, uint8_t* pkt, size_t pkt_len) \n-{\n-    int sock_fd;\n-    struct sockaddr_nl sa;\n-    struct msghdr m;\n-    size_t nread;\n-\n-    printf(\"[INFO] Sending netlink type: %x flags: %x prot: %x seq %x pktlen: %lx\\n\", type, flags, protocol, seq, pkt_len);\n-\n-    memset(&m, 0, sizeof(struct msghdr));\n-    memset(&sa, 0, sizeof(struct sockaddr_nl));\n-    sa.nl_family = AF_NETLINK;\n-\n-    size_t pkt_full_len = sizeof(struct nlmsghdr) + pkt_len;\n-    uint8_t *pkt_full = malloc(pkt_full_len);\n-    memset(pkt_full, 0, pkt_full_len); \n-    memcpy(pkt_full + sizeof(struct nlmsghdr), pkt, pkt_len);\n-\n-    struct nlmsghdr *netlink_hdr = (struct nlmsghdr*)(pkt_full);\n-    netlink_hdr->nlmsg_len = pkt_full_len;\n-    netlink_hdr->nlmsg_type = type;\n-    netlink_hdr->nlmsg_flags = flags;\n-    netlink_hdr->nlmsg_seq = seq;\n-    netlink_hdr->nlmsg_pid = getpid();\n-\n-    if ((sock_fd = socket(PF_NETLINK, SOCK_RAW, protocol)) < 0) {\n-        perror(\"socket\");\n-        return -1;\n-    }\n-\n-    if (bind(sock_fd, (struct sockaddr*)&sa, sizeof(sa)) < 0) {\n-        perror(\"bind\");\n-        return -1;\n-    }\n-\n-    ssize_t r = sendto(\n-        sock_fd, pkt_full, pkt_full_len, 0, \n-        (struct sockaddr*)&sa, sizeof(struct sockaddr_nl)\n-    );\n-\n-    if (r < 0) {\n-        perror(\"sendto\");\n-        return -1;\n-    }\n-\n-    free(pkt_full);\n-\n-    // Eat the response but do nothing with it for now.\n-    m.msg_iovlen = 1;\n-    m.msg_iov = malloc(sizeof(struct iovec));\n-    m.msg_iov->iov_base = malloc(0x1000);\n-    m.msg_iov->iov_len = 0x1000;\n-\n-    if ((nread = recvmsg(sock_fd, &m, 0)) < 0) {\n-        goto error;\n-    }\n-\n-    free(m.msg_iov->iov_base);\n-\n-    close(sock_fd);\n-    return 0;\n-\n-error:\n-    close(sock_fd);\n-    return -1;\n-}\n-\n-/*\n- * Expects a blob in the format of:\n- * Protocol examples, NETLINK_GENERIC, NETLINK_ROUTE\n- * [4-bytes Message Type][4-bytes Message Flags][4-bytes Netlink Protocol][4-bytes size][size bytes data]\n- * [4-bytes Message Type][4-bytes Message Flags][4-bytes Netlink Protocol][4-bytes size][size bytes data]\n- * ....\n- * Returns -1 on a failure, the size consumed\n- */\n-int send_netlink_packet( uint8_t *blob, uint32_t blob_size)\n-{\n-    int index = 0;\n-    uint32_t packet_size = 0;\n-    uint32_t msg_type;\n-    uint32_t msg_flags;\n-    uint32_t protocol;\n-\n-    if ( blob == NULL ) {\n-        return -1;\n-    }\n-\n-    if ( blob_size < 16 ) {\n-        return -1;\n-    }\n-\n-    memcpy(&msg_type, blob, 4);\n-    memcpy(&msg_flags, blob + 4, 4);\n-    memcpy(&protocol, blob + 8, 4);\n-    memcpy(&packet_size, blob + 12, 4);\n-\n-    index += 16;\n-\n-    if ( blob_size - index < packet_size ) {\n-        return -1;\n-    }\n-    \n-    if ( netlink_send( msg_type, msg_flags, protocol, time(NULL), blob + index, packet_size) < 0 ) {\n-        return -1;\n-    }\n-\n-    index += packet_size;\n-\n-    sleep(2);\n-\n-    return index;\n-}\n-\n-/***\n- * Blob begins with a 4 byte command count\n- * [4-bytes command count]\n- * Currently there are two commands:\n- *  0 - send a packet blob\n- *      [4-bytes size][4-bytes send flags][size-bytes packet data]\n- *  1 - send a netlink packet\n- *      [4-bytes Message Type][4-bytes Message Flags][4-bytes Netlink Protocol][4-bytes size][size bytes data]\n- * blob_size MUST be a trusted value\n- */\n-int harness( uint8_t *blob, uint32_t blob_size)\n-{\n-    int index = 0;\n-    uint32_t command, command_count = 0;\n-    uint32_t flags, packet_size = 0;\n-    uint32_t domain, type, protocol;\n-    uint16_t port;\n-    int res;\n-\n-    uint32_t level, optname, optval;\n-\n-    if ( blob == NULL ) {\n-        return -1;\n-    }\n-\n-    // Enable the socket\n-    if ( setup_socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, 6118) < 0 ) {\n-        return -1;\n-    }\n-\n-    \n-    // A blob will at least be 4 bytes even if no packets are sent\n-    if ( blob_size < 4 ) {\n-        return -1;\n-    }\n-\n-    memcpy(&command_count, blob, 4);\n-    index += 4;\n-\n-    printf(\"[INFO] Executing %d commands\\n\", command_count);\n-\n-    for ( int i = 0; i < command_count; i++) {\n-        if ( blob_size - index < 4 ) {\n-            return -1;\n-        }\n-\n-        memcpy(&command, blob + index, 4);\n-        index += 4;\n-\n-        switch ( command ) {\n-        case 0:\n-            if ( blob_size - index < 8 ) {\n-                close(g_sockfd);\n-                return -1;\n-            }\n-\n-            memcpy(&packet_size, blob + index, 4);\n-            memcpy(&flags, blob + index + 4, 4);\n-            index += 8;\n-\n-            if ( blob_size - index < packet_size ) {\n-                close(g_sockfd);\n-                return -1;\n-            }\n-\n-            if ( send_data( blob + index, flags, packet_size ) < 0) {\n-                close(g_sockfd);\n-                return -1;\n-            } \n-\n-            index += packet_size;\n-            break;\n-        case 1:\n-            res = send_netlink_packet( blob + index, blob_size - index);\n-\n-            if ( res < 0 ) {\n-                printf(\"send_netlink_packet() error\\n\");\n-                return -1;\n-            }\n-\n-            index += res;\n-\n-            break;\n-        default:\n-            printf(\"[ERROR] Unknown command: %x\\n\", command);\n-            return -1;\n-\n-        };\n-    }\n-\n-    printf(\"[INFO] Sending completed\\n\");\n-    close(g_sockfd);\n-    return -1;\n-}\n-\n-int main(int argc, char *argv[])\n-{\n-    char *blob = NULL;\n-    struct stat st;\n-    int fd;\n-\n-    if (argc < 2) {\n-        printf(\"Need file\\n\");\n-        return -1;\n-    }\n-\n-    if ( stat(argv[1], &st) != 0) {\n-        printf(\"Failed to stat file\\n\");\n-        return -1;\n-    }\n-\n-    fd = open(argv[1], O_RDONLY);\n-\n-    if ( fd < 0 ) {\n-        printf(\"[ERROR] Failed to open file\\n\");\n-        return -1;\n-    }\n-\n-    blob = malloc(st.st_size);\n-\n-    if ( blob == NULL ) {\n-        return 0;\n-    }\n-\n-    read(fd, blob, st.st_size);\n-\n-    close(fd);\n-\n-    harness(blob, st.st_size);\n-\n-    return 0;\n-}\n", "functions": [["", ""]]}}, "06c7f55b7be9c4e50f6ddeac71dcda9fbd5535e4": {"test_harnesses/linux_test_harness.c": {"diff": "--- a/test_harnesses/linux_test_harness.c\n+++ b/test_harnesses/linux_test_harness.c\n@@ -1,296 +0,0 @@\n-#include <stdio.h>\n-#include <string.h>\n-#include <stdlib.h>\n-#include <arpa/inet.h>\n-#include <sys/socket.h>\n-#include <sys/stat.h>\n-#include <fcntl.h>\n-#include <time.h>\n-#include <unistd.h>\n-#include <errno.h>\n-#include <linux/netlink.h>\n-\n-// globals\n-\n-// variables used for the connecting socket.\n-int g_sockfd = -1;\n-struct sockaddr_in g_sockaddr;\n-\n-int setup_socket(uint32_t domain, uint32_t type, uint32_t protocol, uint16_t port )\n-{\n-    printf(\"[INFO] Opening socket with Domain: %d Type: %d Protocol: %d Port: %d\\n\",\n-        domain, type, protocol, port);\n-\n-    if ((g_sockfd = socket(domain, type, protocol)) < 0) {\n-        g_sockfd = -1;\n-        return -1;\n-    }\n-\n-    memset((char *) &g_sockaddr, 0, sizeof(g_sockaddr));\n-    g_sockaddr.sin_family = domain;\n-    g_sockaddr.sin_port = htons(port);\n-\n-    if (inet_aton(\"127.0.0.1\", &g_sockaddr.sin_addr) == 0) {\n-        close(g_sockfd);\n-        g_sockfd = -1;\n-\n-        return -1;\n-    }\n-    \n-\n-    return 0;\n-}\n-\n-int send_data(uint8_t *buf, uint32_t flags, uint32_t sz)\n-{\n-    printf(\"[INFO] Sending data flags: %x size: %x\\n\", flags, sz);\n-\n-    return sendto( g_sockfd, buf, sz, flags, (struct sockaddr*)&g_sockaddr, sizeof(g_sockaddr) );\n-}\n-\n-// netlink\n-int netlink_send( uint16_t type, uint16_t flags, uint32_t protocol, uint32_t seq, uint8_t* pkt, size_t pkt_len) \n-{\n-    int sock_fd;\n-    struct sockaddr_nl sa;\n-    struct msghdr m;\n-    size_t nread;\n-\n-    printf(\"[INFO] Sending netlink type: %x flags: %x prot: %x seq %x pktlen: %lx\\n\", type, flags, protocol, seq, pkt_len);\n-\n-    memset(&m, 0, sizeof(struct msghdr));\n-    memset(&sa, 0, sizeof(struct sockaddr_nl));\n-    sa.nl_family = AF_NETLINK;\n-\n-    size_t pkt_full_len = sizeof(struct nlmsghdr) + pkt_len;\n-    uint8_t *pkt_full = malloc(pkt_full_len);\n-    memset(pkt_full, 0, pkt_full_len); \n-    memcpy(pkt_full + sizeof(struct nlmsghdr), pkt, pkt_len);\n-\n-    struct nlmsghdr *netlink_hdr = (struct nlmsghdr*)(pkt_full);\n-    netlink_hdr->nlmsg_len = pkt_full_len;\n-    netlink_hdr->nlmsg_type = type;\n-    netlink_hdr->nlmsg_flags = flags;\n-    netlink_hdr->nlmsg_seq = seq;\n-    netlink_hdr->nlmsg_pid = getpid();\n-\n-    if ((sock_fd = socket(PF_NETLINK, SOCK_RAW, protocol)) < 0) {\n-        perror(\"socket\");\n-        return -1;\n-    }\n-\n-    if (bind(sock_fd, (struct sockaddr*)&sa, sizeof(sa)) < 0) {\n-        perror(\"bind\");\n-        return -1;\n-    }\n-\n-    ssize_t r = sendto(\n-        sock_fd, pkt_full, pkt_full_len, 0, \n-        (struct sockaddr*)&sa, sizeof(struct sockaddr_nl)\n-    );\n-\n-    if (r < 0) {\n-        perror(\"sendto\");\n-        return -1;\n-    }\n-\n-    free(pkt_full);\n-\n-    // Eat the response but do nothing with it for now.\n-    m.msg_iovlen = 1;\n-    m.msg_iov = malloc(sizeof(struct iovec));\n-    m.msg_iov->iov_base = malloc(0x1000);\n-    m.msg_iov->iov_len = 0x1000;\n-\n-    if ((nread = recvmsg(sock_fd, &m, 0)) < 0) {\n-        goto error;\n-    }\n-\n-    free(m.msg_iov->iov_base);\n-\n-    close(sock_fd);\n-    return 0;\n-\n-error:\n-    close(sock_fd);\n-    return -1;\n-}\n-\n-/*\n- * Expects a blob in the format of:\n- * Protocol examples, NETLINK_GENERIC, NETLINK_ROUTE\n- * [4-bytes Message Type][4-bytes Message Flags][4-bytes Netlink Protocol][4-bytes size][size bytes data]\n- * [4-bytes Message Type][4-bytes Message Flags][4-bytes Netlink Protocol][4-bytes size][size bytes data]\n- * ....\n- * Returns -1 on a failure, the size consumed\n- */\n-int send_netlink_packet( uint8_t *blob, uint32_t blob_size)\n-{\n-    int index = 0;\n-    uint32_t packet_size = 0;\n-    uint32_t msg_type;\n-    uint32_t msg_flags;\n-    uint32_t protocol;\n-\n-    if ( blob == NULL ) {\n-        return -1;\n-    }\n-\n-    if ( blob_size < 16 ) {\n-        return -1;\n-    }\n-\n-    memcpy(&msg_type, blob, 4);\n-    memcpy(&msg_flags, blob + 4, 4);\n-    memcpy(&protocol, blob + 8, 4);\n-    memcpy(&packet_size, blob + 12, 4);\n-\n-    index += 16;\n-\n-    if ( blob_size - index < packet_size ) {\n-        return -1;\n-    }\n-    \n-    if ( netlink_send( msg_type, msg_flags, protocol, time(NULL), blob + index, packet_size) < 0 ) {\n-        return -1;\n-    }\n-\n-    index += packet_size;\n-\n-    sleep(2);\n-\n-    return index;\n-}\n-\n-/***\n- * Blob begins with a 4 byte command count\n- * [4-bytes command count]\n- * Currently there are two commands:\n- *  0 - send a packet blob\n- *      [4-bytes size][4-bytes send flags][size-bytes packet data]\n- *  1 - send a netlink packet\n- *      [4-bytes Message Type][4-bytes Message Flags][4-bytes Netlink Protocol][4-bytes size][size bytes data]\n- * blob_size MUST be a trusted value\n- */\n-int harness( uint8_t *blob, uint32_t blob_size)\n-{\n-    int index = 0;\n-    uint32_t command, command_count = 0;\n-    uint32_t flags, packet_size = 0;\n-    uint32_t domain, type, protocol;\n-    uint16_t port;\n-    int res;\n-\n-    uint32_t level, optname, optval;\n-\n-    if ( blob == NULL ) {\n-        return -1;\n-    }\n-\n-    // Enable the socket\n-    if ( setup_socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP, 6118) < 0 ) {\n-        return -1;\n-    }\n-\n-    \n-    // A blob will at least be 4 bytes even if no packets are sent\n-    if ( blob_size < 4 ) {\n-        return -1;\n-    }\n-\n-    memcpy(&command_count, blob, 4);\n-    index += 4;\n-\n-    printf(\"[INFO] Executing %d commands\\n\", command_count);\n-\n-    for ( int i = 0; i < command_count; i++) {\n-        if ( blob_size - index < 4 ) {\n-            return -1;\n-        }\n-\n-        memcpy(&command, blob + index, 4);\n-        index += 4;\n-\n-        switch ( command ) {\n-        case 0:\n-            if ( blob_size - index < 8 ) {\n-                close(g_sockfd);\n-                return -1;\n-            }\n-\n-            memcpy(&packet_size, blob + index, 4);\n-            memcpy(&flags, blob + index + 4, 4);\n-            index += 8;\n-\n-            if ( blob_size - index < packet_size ) {\n-                close(g_sockfd);\n-                return -1;\n-            }\n-\n-            if ( send_data( blob + index, flags, packet_size ) < 0) {\n-                close(g_sockfd);\n-                return -1;\n-            } \n-\n-            index += packet_size;\n-            break;\n-        case 1:\n-            res = send_netlink_packet( blob + index, blob_size - index);\n-\n-            if ( res < 0 ) {\n-                printf(\"send_netlink_packet() error\\n\");\n-                return -1;\n-            }\n-\n-            index += res;\n-\n-            break;\n-        default:\n-            printf(\"[ERROR] Unknown command: %x\\n\", command);\n-            return -1;\n-\n-        };\n-    }\n-\n-    printf(\"[INFO] Sending completed\\n\");\n-    close(g_sockfd);\n-    return -1;\n-}\n-\n-int main(int argc, char *argv[])\n-{\n-    char *blob = NULL;\n-    struct stat st;\n-    int fd;\n-\n-    if (argc < 2) {\n-        printf(\"Need file\\n\");\n-        return -1;\n-    }\n-\n-    if ( stat(argv[1], &st) != 0) {\n-        printf(\"Failed to stat file\\n\");\n-        return -1;\n-    }\n-\n-    fd = open(argv[1], O_RDONLY);\n-\n-    if ( fd < 0 ) {\n-        printf(\"[ERROR] Failed to open file\\n\");\n-        return -1;\n-    }\n-\n-    blob = malloc(st.st_size);\n-\n-    if ( blob == NULL ) {\n-        return 0;\n-    }\n-\n-    read(fd, blob, st.st_size);\n-\n-    close(fd);\n-\n-    harness(blob, st.st_size);\n-\n-    return 0;\n-}\n", "functions": [["", ""]]}}, "ea6ad07cd28659fd73beb1e80965f7946b0d3d84": {"net/tipc/link.c": {"diff": "--- a/net/tipc/link.c\n+++ b/net/tipc/link.c\n@@ -1442,7 +1442,7 @@\n \t\tp = (struct tipc_gap_ack_blks *)msg_data(hdr);\n \t\tsz = ntohs(p->len);\n \t\t/* Sanity check */\n-\t\tif (sz == struct_size(p, gacks, p->ugack_cnt + p->bgack_cnt)) {\n+\t\tif (sz == struct_size(p, gacks, size_add(p->ugack_cnt, p->bgack_cnt))) {\n \t\t\t/* Good, check if the desired type exists */\n \t\t\tif ((uc && p->ugack_cnt) || (!uc && p->bgack_cnt))\n \t\t\t\tgoto ok;\n@@ -1529,7 +1529,7 @@\n \t\t\t__tipc_build_gap_ack_blks(ga, l, ga->bgack_cnt) : 0;\n \n \t/* Total len */\n-\tlen = struct_size(ga, gacks, ga->bgack_cnt + ga->ugack_cnt);\n+\tlen = struct_size(ga, gacks, size_add(ga->bgack_cnt, ga->ugack_cnt));\n \tga->len = htons(len);\n \treturn len;\n }\n", "functions": [["", ""], ["", ""]]}}, "283f9ce03e5ce39293d266fc1dcfbee023059fa9": {"net/tipc/netlink_compat.c": {"diff": "--- a/net/tipc/netlink_compat.c\n+++ b/net/tipc/netlink_compat.c\n@@ -166,7 +166,7 @@\n \tint str_len = strlen(str) + 1;\n \tstruct sk_buff *buf;\n \n-\tbuf = tipc_tlv_alloc(TLV_SPACE(str_len));\n+\tbuf = tipc_tlv_alloc(str_len);\n \tif (buf)\n \t\ttipc_add_tlv(buf, TIPC_TLV_ERROR_STRING, str, str_len);\n \n", "functions": [["", ""]]}}, "747400b971e2131ef86fbab1aa6350f181e40310": {"net/tipc/crypto.c": {"diff": "--- a/net/tipc/crypto.c\n+++ b/net/tipc/crypto.c\n@@ -35,6 +35,7 @@\n  */\n \n #include <crypto/aead.h>\n+#include <kunit/test-bug.h>\n #include <crypto/aes.h>\n #include <crypto/rng.h>\n #include \"crypto.h\"\n@@ -1461,12 +1462,10 @@\n \n \tif (*crypto)\n \t\treturn -EEXIST;\n-\n \t/* Allocate crypto */\n \tc = kzalloc(sizeof(*c), GFP_ATOMIC);\n \tif (!c)\n \t\treturn -ENOMEM;\n-\n \t/* Allocate workqueue on TX */\n \tif (!node) {\n \t\tc->wq = alloc_ordered_workqueue(\"tipc_crypto\", 0);\n@@ -1497,6 +1496,7 @@\n \tc->timer2 = jiffies;\n \tc->rekeying_intv = TIPC_REKEYING_INTV_DEF;\n \tspin_lock_init(&c->lock);\n+\n \tscnprintf(c->name, 48, \"%s(%s)\", (is_rx(c)) ? \"RX\" : \"TX\",\n \t\t  (is_rx(c)) ? tipc_node_get_id_str(c->node) :\n \t\t\t       tipc_own_id_string(c->net));\n@@ -1507,6 +1507,7 @@\n \t\tINIT_DELAYED_WORK(&c->work, tipc_crypto_work_tx);\n \n \t*crypto = c;\n+\n \treturn 0;\n }\n \n@@ -2277,40 +2278,31 @@\n  */\n static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)\n {\n-\tstruct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;\n+\n+\tstruct tipc_crypto *tx  = NULL;\n \tstruct tipc_aead_key *skey = NULL;\n \tu16 key_gen = msg_key_gen(hdr);\n \tu32 size = msg_data_sz(hdr);\n \tu8 *data = msg_data(hdr);\n \tunsigned int keylen;\n-\n-\t/* Verify whether the size can exist in the packet */\n-\tif (unlikely(size < sizeof(struct tipc_aead_key) + TIPC_AEAD_KEYLEN_MIN)) {\n-\t\tpr_debug(\"%s: message data size is too small\\n\", rx->name);\n-\t\tgoto exit;\n-\t}\n-\n+\t\n+\tif(rx->net){\n+\t\ttx = tipc_net(rx->net)->crypto_tx;\n+\t}\n \tkeylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));\n-\n-\t/* Verify the supplied size values */\n-\tif (unlikely(size != keylen + sizeof(struct tipc_aead_key) ||\n-\t\t     keylen > TIPC_AEAD_KEY_SIZE_MAX)) {\n-\t\tpr_debug(\"%s: invalid MSG_CRYPTO key size\\n\", rx->name);\n-\t\tgoto exit;\n-\t}\n \n \tspin_lock(&rx->lock);\n \tif (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {\n \t\tpr_err(\"%s: key existed <%p>, gen %d vs %d\\n\", rx->name,\n \t\t       rx->skey, key_gen, rx->key_gen);\n-\t\tgoto exit_unlock;\n+\t\tgoto exit;\n \t}\n \n \t/* Allocate memory for the key */\n \tskey = kmalloc(size, GFP_ATOMIC);\n \tif (unlikely(!skey)) {\n \t\tpr_err(\"%s: unable to allocate memory for skey\\n\", rx->name);\n-\t\tgoto exit_unlock;\n+\t\tgoto exit;\n \t}\n \n \t/* Copy key from msg data */\n@@ -2325,14 +2317,13 @@\n \trx->nokey = 0;\n \tmb(); /* for nokey flag */\n \n-exit_unlock:\n+exit:\n \tspin_unlock(&rx->lock);\n-\n-exit:\n \t/* Schedule the key attaching on this crypto */\n+\tif (rx->net){\n \tif (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))\n \t\treturn true;\n-\n+\t}\n \treturn false;\n }\n \n@@ -2473,3 +2464,7 @@\n \t/* Re-schedule rekeying if any */\n \ttipc_crypto_rekeying_sched(tx, false, 0);\n }\n+\n+#ifdef CONFIG_TIPC_TEST\n+#include \"tipc_test.c\"\n+#endif\n", "functions": [["", ""], ["", ""], ["", ""], ["", ""], ["", ""], ["", ""], ["", ""]]}}, "dccff603a37b25a318187e98423539ec06236670": {"net/ipv6/icmp.c": {"diff": "--- a/net/ipv6/icmp.c\n+++ b/net/ipv6/icmp.c\n@@ -23,6 +23,7 @@\n  *\tRandy Dunlap and\n  *\tYOSHIFUJI Hideaki @USAGI:\tPer-interface statistics support\n  *\tKazunori MIYAZAWA @USAGI:       change output process to use ip6_append_data\n+ *\tBoldmoon:\t\t\t\t\tUpdate outdated variables\n  */\n \n #define pr_fmt(fmt) \"IPv6: \" fmt\n@@ -135,21 +136,21 @@\n \n static bool is_ineligible(const struct sk_buff *skb)\n {\n-\tint ptr = (u8 *)(ipv6_hdr(skb) + 1) - skb->data;\n-\tint len = skb->len - ptr;\n+\tint ptr_data = (u8 *)(ipv6_hdr(skb) + 1) - skb->data;\n+\tint len = skb->len - ptr_data;\n \t__u8 nexthdr = ipv6_hdr(skb)->nexthdr;\n \t__be16 frag_off;\n \n \tif (len < 0)\n \t\treturn true;\n \n-\tptr = ipv6_skip_exthdr(skb, ptr, &nexthdr, &frag_off);\n-\tif (ptr < 0)\n+\tptr_data = ipv6_skip_exthdr(skb, ptr_data, &nexthdr, &frag_off);\n+\tif (ptr_data < 0)\n \t\treturn false;\n \tif (nexthdr == IPPROTO_ICMPV6) {\n \t\tu8 _type, *tp;\n \t\ttp = skb_header_pointer(skb,\n-\t\t\tptr+offsetof(struct icmp6hdr, icmp6_type),\n+\t\t\tptr_data+offsetof(struct icmp6hdr, icmp6_type),\n \t\t\tsizeof(_type), &_type);\n \n \t\t/* Based on RFC 8200, Section 4.5 Fragment Header, return\n@@ -1190,19 +1191,19 @@\n \n struct ctl_table * __net_init ipv6_icmp_sysctl_init(struct net *net)\n {\n-\tstruct ctl_table *table;\n-\n-\ttable = kmemdup(ipv6_icmp_table_template,\n+\tstruct ctl_table *table_ret;\n+\n+\ttable_ret = kmemdup(ipv6_icmp_table_template,\n \t\t\tsizeof(ipv6_icmp_table_template),\n \t\t\tGFP_KERNEL);\n \n-\tif (table) {\n-\t\ttable[0].data = &net->ipv6.sysctl.icmpv6_time;\n-\t\ttable[1].data = &net->ipv6.sysctl.icmpv6_echo_ignore_all;\n-\t\ttable[2].data = &net->ipv6.sysctl.icmpv6_echo_ignore_multicast;\n-\t\ttable[3].data = &net->ipv6.sysctl.icmpv6_echo_ignore_anycast;\n-\t\ttable[4].data = &net->ipv6.sysctl.icmpv6_ratemask_ptr;\n-\t}\n-\treturn table;\n+\tif (table_ret) {\n+\t\ttable_ret[0].data = &net->ipv6.sysctl.icmpv6_time;\n+\t\ttable_ret[1].data = &net->ipv6.sysctl.icmpv6_echo_ignore_all;\n+\t\ttable_ret[2].data = &net->ipv6.sysctl.icmpv6_echo_ignore_multicast;\n+\t\ttable_ret[3].data = &net->ipv6.sysctl.icmpv6_echo_ignore_anycast;\n+\t\ttable_ret[4].data = &net->ipv6.sysctl.icmpv6_ratemask_ptr;\n+\t}\n+\treturn table_ret;\n }\n #endif\n", "functions": [["", ""], ["", ""], ["", ""]]}}}}