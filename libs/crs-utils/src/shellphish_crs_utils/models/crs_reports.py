from enum import Enum
import hashlib
from pydantic import Field
from annotated_types import Len
from typing import List, Optional, Any, Annotated, Literal, Dict, Union
from pathlib import Path

from shellphish_crs_utils.models.base import ShellphishBaseModel
from shellphish_crs_utils.models.constraints import (
    PDT_ID,
    MD5_CONSTRAINTS,
    SHA1_CONSTRAINTS,
)
from shellphish_crs_utils.models.crash_reports import (
    CallTrace,
    DedupSanitizerReport,
    SanitizerReport,
)
from shellphish_crs_utils.models.symbols import POI
from shellphish_crs_utils.models.target import HarnessInfo, CrashingInputMetadata
from shellphish_crs_utils.models.indexer import GlobalVariableReference
from shellphish_crs_utils.models.organizer_evaluation import OrganizerCrashEvaluation, SignificanceEnum
import yaml

class DedupInfoKind(Enum):
    FULL = "full"
    OSS_FUZZ = "oss-fuzz"
    SHELLPHISH = "shellphish"
    ORGANIZERS = "organizers"

class DedupInfo(ShellphishBaseModel):
    kind: DedupInfoKind
    pdt_project_id: PDT_ID = Field(
        description="The pydatatask project id this deduplication information is associated with"
    )
    consistent_sanitizers: Annotated[List[str], Len(min_length=1)]
    tokens: Dict[str, str]

    def hash(self) -> str:
        """
        Get the hash of the deduplication information.
        :return: A string representing the hash of the deduplication information.
        """
        return hashlib.md5(self.identifier().encode("utf-8")).hexdigest()

    def identifier(self) -> str:
        s = f"{self.pdt_project_id}--{self.kind.value}--{','.join(sorted(self.consistent_sanitizers))}==="
        s += "===".join(f"{k}--{v}" for k, v in sorted(self.tokens.items()))
        return s

    def canonical_representation(self) -> str:
        """
        Get the canonical representation of the deduplication information.
        :return: A string representing the canonical representation of the deduplication information.
        """
        return yaml.safe_dump(
            {
                "kind": self.kind.value,
                "pdt_project_id": self.pdt_project_id,
                "consistent_sanitizers": self.consistent_sanitizers,
                "tokens": self.tokens,
            },
            sort_keys=True,
            default_flow_style=False,
        )

class POIReport(HarnessInfo):
    harness_info_id: str = Field(description="The pydatatask harness info id")
    organizer_crash_eval: OrganizerCrashEvaluation = Field(
        description="The crash evaluation generated by the organizer's interaction scripts"
    )
    detection_strategy: str = Field(
        description="The detection strategy used to find the crash"
    )
    fuzzer: str = Field(description="The fuzzer used to find the crash")
    consistent_sanitizers: Annotated[List[str], Len(min_length=1)] = Field(
        description="The sanitizers that are consistently triggered in the crash"
    )
    inconsistent_sanitizers: List[str] = Field(
        description="The sanitizers that are inconsistently triggered in the crash"
    )
    # sanitizer_history: Annotated[List[Annotated[List[Annotated[str, ID_CONSTRAINTS]], Len(min_length=1)]], Len(min_length=1)] = Field(description="The history of sanitizers triggered in the crash")
    crash_report_id: str = Field(
        description="The pydatatask id of the representative crash report (md5sum)"
    )
    crash_reason: str = Field(description="The reason for the crash")
    pois: Annotated[List[POI], Len(min_length=1)] = Field(
        description="The points of interest in the crash"
    )
    stack_traces: Dict[str, CallTrace] = Field(
        description="The call traces of the crash (Currently mostly identical to the pois in use). This maps the call trace type (e.g. main, alloc, free, etc.) to the call trace.",
        default_factory=dict,
    )
    extra_context: Optional[str] = Field(
        description="Extra context about the crash (e.g. other reports than the fatal one. Usually happens with ubsan reports.)",
        default=None,
    )
    additional_information: Any = Field(
        description="Additional information about the crash (None in all current cases)",
        default=None,
    )

    def get_dedup_info(self, kind: Union[DedupInfoKind, str]) -> DedupInfo:
        """
        Get the deduplication information for the OSS-Fuzz deduplication strategy.
        :return: A DedupInfo object.
        """
        if isinstance(kind, str):
            kind = DedupInfoKind(kind)

        dedup_tokens = {}
        if kind in (DedupInfoKind.FULL, DedupInfoKind.SHELLPHISH, DedupInfoKind.FULL):
            for reason, ct in self.stack_traces.items():
                getter = {
                    DedupInfoKind.OSS_FUZZ:     lambda: ct.get_dedup_token(),
                    DedupInfoKind.SHELLPHISH:   lambda: ct.get_dedup_token_shellphish(num_entries=3),
                    DedupInfoKind.FULL:         lambda: ct.get_dedup_token_full(),
                }.get(kind or DedupInfoKind.OSS_FUZZ, None)
                assert getter is not None
                dedup_tokens[reason] = getter()

        elif kind == DedupInfoKind.ORGANIZERS:
            dedup_tokens['significance'] = str(self.organizer_crash_eval.significance.value)
            dedup_tokens['crash-state'] = self.organizer_crash_eval.crash_state
            if self.organizer_crash_eval.instrumentation_key:
                dedup_tokens['instrumentation-key'] = self.organizer_crash_eval.instrumentation_key

        else:
            raise ValueError(f"Unknown DedupInfoKind: {kind}")

        return DedupInfo(
            kind=kind,
            pdt_project_id=self.project_id,
            consistent_sanitizers=self.consistent_sanitizers,
            tokens=dedup_tokens,
        )

    def get_dedup_info_full(self) -> DedupInfo:
        return self.get_dedup_info(DedupInfoKind.FULL)

    def get_dedup_info_oss_fuzz(self) -> DedupInfo:
        return self.get_dedup_info(DedupInfoKind.OSS_FUZZ)

    def get_dedup_info_shellphish(self) -> DedupInfo:
        return self.get_dedup_info(DedupInfoKind.SHELLPHISH)

    def get_dedup_info_organizers(self) -> DedupInfo:
        return self.get_dedup_info(DedupInfoKind.ORGANIZERS)

    def get_all_dedup_infos(self) -> List[DedupInfo]:
        return [
            self.get_dedup_info(kind)
            for kind in DedupInfoKind
        ]


# class JazzerStackFrame(ShellphishBaseModel):
#     text: str = Field(description="The text of the stack frame line in jazzer output", default="")
#     package: Optional[str] = Field(description="The package in the stack frame line", default=None)
#     file: Optional[str] = Field(description="The file in the stack frame line", default=None)
#     line: Optional[int] = Field(description="The line in the stack frame line", default=None)
#     function: Optional[str] = Field(description="The function in the stack frame line", default=None)
#     cls: Optional[str] = Field(description="The class in the stack frame line", default=None)

# class RawJazzerReport(ShellphishBaseModel):
#     triggered_sanitizers: List[str] = Field(description="The sanitizers triggered in the crash")
#     report: bytes = Field(description="The raw jazzer report")
#     error_line: str = Field(description="The error line in the jazzer report")
#     argument: Optional[str] = Field(description="The argument in the jazzer report linked to the crash")
#     stack_trace: List[JazzerStackFrame] = Field(description="The stack trace in the jazzer report", default_factory=list)

# class RawAsanReport(ShellphishBaseModel):
#     triggered_sanitizers: List[Annotated[str, ID_CONSTRAINTS]] = Field(description="The sanitizers triggered in the crash")
#     report: bytes = Field(description="The raw asan report")
#     error_line: str = Field(description="The asan specified error line")

# class RawKasanReport(ShellphishBaseModel):
#     triggered_sanitizers: List[Annotated[str, ID_CONSTRAINTS]] = Field(description="The sanitizers triggered in the crash")
#     report: bytes = Field(description="The raw kasan report")

# class CrashReport(ShellphishBaseModel):
#     reports: List[Union[RawJazzerReport, RawAsanReport, RawKasanReport]] = Field(description="The raw reports of the crash")

class AIxCCDedupValues(ShellphishBaseModel):
    significance: SignificanceEnum = Field(description="The exit code of the deduplication values")
    crash_state: List[str] = Field(description="The crash state of the deduplication values")
    instrumentation_state: List[str] = Field(description="The instrumentation state of the deduplication values")

class RawPoVReport(ShellphishBaseModel):
    parser: Literal["failed", "jazzer", "asan", "kasan"] = Field(
        description="The fuzzer sanitizer that generated the PoV"
    )
    exception: Optional[str] = Field(
        description="The exception raised during report parsing", default=None
    )
    traceback: Optional[str] = Field(
        description="The traceback of the exeception raised during report parsing",
        default=None,
    )
    unparsed: Optional[bytes] = Field(
        description="The raw unparsed report (None unless an error occurs)",
        default=None,
    )
    extra_context: Optional[str] = Field(
        description="Extra context about the crash (e.g. other reports than the fatal one. Usually happens with ubsan reports.)",
        default=None,
    )
    organizer_crash_eval: OrganizerCrashEvaluation = Field(
        description="The crash evaluation generated by the organizer's interaction scripts",
    )
    crash_report: Optional[SanitizerReport] = Field(
        description="The parsed crash report (None if a parsing error occurs or no crash was found)",
        default=None,
    )
    dedup_crash_report: Optional[DedupSanitizerReport] = Field(
        description="The deduplicated crash report (None if a parsing error occurs or no crash was found)",
        default=None,
    )
    triggered_sanitizers: List[str] = Field(
        description="All sanitizers triggered in the crash"
    )

    def clean_invalid_utf8(self):
        """
        Clean invalid UTF-8 sequences from the unparsed bytes field.
        First tries to decode as UTF-8, and if that fails, strips invalid characters.
        """

        if self.crash_report is not None:
            self.crash_report.clean_invalid_utf8()
        
        if self.unparsed is not None and isinstance(self.unparsed, bytes):
            self.unparsed = self.unparsed.decode('utf-8', errors='ignore').encode('utf-8')


class RunImageResult(ShellphishBaseModel):
    task_success: bool = Field(description="Whether the task was successful")
    run_exit_code: Optional[int] = Field(description="The exit code of the command run in the background",
                                         default=None)
    time_scheduled: float = Field(description="The time the command was scheduled")
    time_start: float = Field(description="The time the command started")
    time_end: float = Field(description="The time the command terminated")
    time_taken: float = Field(description="The time taken to run the command")
    stdout: bytes = Field(
        description="The stdout of the process inside the docker run by run.sh"
    )
    stderr: bytes = Field(
        description="The stderr of the process inside the docker run by run.sh"
    )

    container_id: Optional[str] = Field(
        description="The container id of the docker run by run.sh for a local run",
        default=None,
    )
    container_name: Optional[str] = Field(
        description="The container name of the docker run by run.sh for a local run",
        default=None,
    )
    out_dir: Optional[Path] = Field(
        description="The output directory of the docker run by run.sh for a local run",
        default=None,
    )
    build_job_pdt_id: Optional[PDT_ID] = Field(
        description="The pydatatask id of the build job that was run to build the image",
        default=None,
    )

class BuildTargetResult(RunImageResult):
    build_success: bool = Field(description="Whether the build was successful")
    build_request_id: Optional[PDT_ID] = Field(
        description="The request id of the build job that was run to build the image",
        default=None,
    )


class RunImageInBackgroundResult(ShellphishBaseModel):
    task_success: bool = Field(description="Whether the task was successful")
    run_exit_code: int = Field(description="The exit code of the command run in the background")
    time_scheduled: float = Field(description="The time the command was scheduled")
    time_start: float = Field(description="The time the command started")

    container_id: Optional[str] = Field(
        description="The container id of the docker run by run.sh for a local run",
        default=None,
    )
    container_name: Optional[str] = Field(
        description="The container name of the docker run by run.sh for a local run",
        default=None,
    )
    out_dir: Optional[Path] = Field(
        description="The output directory of the docker run by run.sh for a local run",
        default=None,
    )


class RunPoVResult(RunImageResult):
    # exitcode: int = Field(description="The exit code of the run_pov")
    pov: RawPoVReport = Field(
        description="The raw PoV report generated during the run_pov"
    )

class DedupPoVReportRepresentativeMetadata(HarnessInfo):
    original_crash_id: PDT_ID = Field(
        description="The pydatatask crash harness-input-id of the first crash that had this deduplicated report."
    )
    consistent_sanitizers: List[str] = Field(
        description="The sanitizers that are consistently triggered in the crash"
    )
    harness_info_id: PDT_ID = Field(
        description="The pydatatask harness info id of the representative crash report"
    )

class PoVReport(CrashingInputMetadata, RawPoVReport):
    consistent_sanitizers: Annotated[List[str], Len(min_length=1)] = Field(
        description="The sanitizers that are consistently triggered in the crash"
    )
    inconsistent_sanitizers: List[str] = Field(
        description="The sanitizers that are inconsistently triggered in the crash"
    )


    def get_dedup_info(self, kind: Union[DedupInfoKind, str]) -> DedupInfo:
        """
        Get the deduplication information for the OSS-Fuzz deduplication strategy.
        :return: A DedupInfo object.
        """
        if isinstance(kind, str):
            kind = DedupInfoKind(kind)

        dedup_tokens = {}
        if kind in (DedupInfoKind.FULL, DedupInfoKind.SHELLPHISH, DedupInfoKind.OSS_FUZZ):
            stack_traces = {}
            if self.dedup_crash_report and self.dedup_crash_report.stack_traces:
            # Use the dedup_crash_report stack traces if available
                stack_traces = self.dedup_crash_report.stack_traces
            for reason, ct in stack_traces.items():
                getter = {
                    DedupInfoKind.OSS_FUZZ:     lambda: ct.get_dedup_token(),
                    DedupInfoKind.SHELLPHISH:   lambda: ct.get_dedup_token_shellphish(num_entries=3),
                    DedupInfoKind.FULL:         lambda: ct.get_dedup_token_full(),
                }.get(kind or DedupInfoKind.OSS_FUZZ, None)
                assert getter is not None
                dedup_tokens[reason] = getter()
        elif kind == DedupInfoKind.ORGANIZERS:
            dedup_tokens['significance'] = str(self.organizer_crash_eval.significance.value)
            dedup_tokens['crash-state'] = self.organizer_crash_eval.crash_state
            if self.organizer_crash_eval.instrumentation_key:
                dedup_tokens['instrumentation-key'] = self.organizer_crash_eval.instrumentation_key
        else:
            raise ValueError(f"Unknown DedupInfoKind: {kind}")

        return DedupInfo(
            kind=kind,
            pdt_project_id=self.project_id,
            consistent_sanitizers=self.consistent_sanitizers,
            tokens=dedup_tokens,
        )

    def get_dedup_info_full(self) -> DedupInfo:
        return self.get_dedup_info(DedupInfoKind.FULL)

    def get_dedup_info_oss_fuzz(self) -> DedupInfo:
        return self.get_dedup_info(DedupInfoKind.OSS_FUZZ)

    def get_dedup_info_shellphish(self) -> DedupInfo:
        return self.get_dedup_info(DedupInfoKind.SHELLPHISH)

    def get_all_dedup_infos(self) -> List[DedupInfo]:
        return [
            self.get_dedup_info(kind)
            for kind in DedupInfoKind
        ]


class RepresentativeFullPoVReport(PoVReport):
    run_pov_result: RunPoVResult = Field(description="The run_pov result of the crash")
    original_crash_id: PDT_ID = Field(
        description="The non-deduplicated pydatatask crash id"
    )
    crash_report_id: Annotated[str, MD5_CONSTRAINTS] = Field(
        description="The md5sum of the crash report"
    )
    sanitizer_history: Annotated[
        List[Annotated[List[str], Len(min_length=1)]], Len(min_length=1)
    ] = Field(description="The history of sanitizers triggered in the crash")


# class ASANReport(HarnessInfo):
#     harness_info_id: PDT_ID = Field(description="The pydatatask harness info id")
#     crash_report_id: PDT_ID = Field(description="The pydatatask id of the representative crash report (md5sum)")
#     consistent_sanitizers: Annotated[List[Annotated[str, ID_CONSTRAINTS]], Len(min_length=1)] = Field(description="The sanitizers that are consistently triggered in the crash")
#     inconsistent_sanitizers: List[str] = Field(description="The sanitizers that are inconsistently triggered in the crash", default_factory=list)
#     sanitizer_history: Annotated[List[Annotated[List[Annotated[str, ID_CONSTRAINTS]], Len(min_length=1)]], Len(min_length=1)] = Field(description="The history of sanitizers triggered in the crash")
#     fuzzer: str = Field(description="The fuzzer used to find the crash")
#     sanitizer: str = Field(description="The sanitizer present in the crash")
#     crash_type: str = Field(description="The type of crash")
#     stack_traces: Dict[str, List[ASANStackTrace]] = Field(description="The stack traces of the crash", default_factory=dict)


class DedupedFirstCrashCommitReport(ShellphishBaseModel):
    crashing_commit: Annotated[str, SHA1_CONSTRAINTS] = Field(
        description="The introducing commit that caused the crash"
    )
    sanitizer_ids: Annotated[List[str], Len(min_length=1)] = Field(
        description="The sanitizers triggered in the crash"
    )
    cp_harness_name: str = Field(
        description="The challenge project harness name of the crash"
    )
    project_id: PDT_ID = Field(description="The pydatatask id of the project")


class FirstCrashCommitReport(ShellphishBaseModel):
    crashing_commit: Annotated[str, SHA1_CONSTRAINTS] = Field(
        description="The introducing commit that caused the crash"
    )
    cp_source: str = Field(
        description="The challenge project source linked to the crash"
    )
    sanitizer_ids: Annotated[List[str], Len(min_length=1)] = Field(
        description="The sanitizers triggered in the crash"
    )
    crash_report_id: PDT_ID = Field(
        description="The pydatatask id of the representative crash report (md5sum)"
    )
    crash_id: PDT_ID = Field(description="The pydatatask id of the crash")
    cp_harness_name: str = Field(
        description="The challenge project harness name of the crash"
    )


class LocationOfInterest(ShellphishBaseModel):
    file: str = Field(description="The file containing the point of interest")
    function: str = Field(description="The function containing the point of interest")
    start_line: int = Field(
        description="The start line number of the point of interest"
    )
    end_line: int = Field(description="The end line number of the point of interest")
    signature: str = Field(description="The signature of the point of interest", default="")


class SuggestedPatch(ShellphishBaseModel):
    description: str = Field(description="The description of the patch")


class RootCauseReport(ShellphishBaseModel):
    found_root_cause: bool = Field(description="Whether the root cause was found")
    description: str = Field(description="The root cause of the crash")
    dataflow: str = Field(description="The dataflow of the crash")
    bug_locations: List[LocationOfInterest] = Field(
        description="The location of the bug in the code"
    )
    bug_classes: List[str] = Field(description="The potential classes of the bug")
    root_cause_locations: List[LocationOfInterest] = Field(
        description="The root cause locations of the crash"
    )
    patches: List[SuggestedPatch] = Field(description="The patches to fix the crash")
    errored: bool = Field(
        description="Whether there was an error in the root cause analysis"
    )

class KumushiCodeFunction(ShellphishBaseModel):
    name: str = Field(description="The name of the function")
    start_line: int = Field(description="The start line of the function")
    end_line: int = Field(description="The end line of the function")
    file_path: str = Field(description="The path to the file")
    code: str | None = Field(default=None, description="The code of the function")
    global_vars: list[GlobalVariableReference] | None = Field(default=None, description="The global variables of the function")
    version: str | None = Field(default=None, description="The version of the function")

class KumushiPOI(ShellphishBaseModel):
    sources: list[int] = Field(description="The source we collect the POI from")
    crash_line_number: int | None = Field(default=None, description="The line number of the crash")
    crash_line: str | None = Field(default=None, description="The line text of the crash")
    code_function: KumushiCodeFunction = Field(description="The code function of the POI")

class KumushiPOICluster(ShellphishBaseModel):
    poi_cluster: List[KumushiPOI] = Field(description="The Kumushi POI cluster")
    reasoning: str | None = Field(default=None, description="The reasoning behind the cluster")


class KumushiRootCauseReport(ShellphishBaseModel):
    poi_clusters: List[KumushiPOICluster] = Field(description="The Kumushi POI clusters")
    rca_hash: str = Field(description="The hash of the RCA")

class PatchRequestMeta(ShellphishBaseModel):
    request_type: Literal["refine", "patch"] = Field(description="The type for this request (refine/patch)")
    poi_report_id: str = Field(description="The poi report ID")
    failed_functionality: bool = Field(description="Whether the patch failed", default=False)
    patcher_name: str | None = Field(description="The patcher that create the previous patch", default=None)
    patch_id: str | None = Field(description="The id of patch that need to be refined", default=None)
    bucket_id: str | None = Field(description="The bucket ID", default=None)

class RunTestsResult(ShellphishBaseModel):
    tests_exist: bool = Field(description="True when the tests exist. When false, all other data is invalid")
    timedout: bool = Field(description="True when the tests never finished. Normally should be False.", default=False)
    all_passed: bool = Field(description="All testcases passed")
    stdout: str = Field(description="Tests stdout", default="")
    stderr: str = Field(description="Tests stderr", default="")

class RunOssFuzzBuildCheckResult(ShellphishBaseModel):
    all_passed: bool = Field(description="All testcases passed")
    timedout: bool = Field(description="True when the tests never finished. Normally should be False.", default=False)
    internal_error: bool = Field(description="True when an internal error occurred during the build check", default=False)
    stdout: str = Field(description="Tests stdout", default="")
    stderr: str = Field(description="Tests stderr", default="")