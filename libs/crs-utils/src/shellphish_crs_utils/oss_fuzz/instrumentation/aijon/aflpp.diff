diff --git a/GNUmakefile b/GNUmakefile
index d33d23b5..f2d94787 100644
--- a/GNUmakefile
+++ b/GNUmakefile
@@ -478,8 +478,11 @@ src/afl-forkserver.o : $(COMM_HDR) src/afl-forkserver.c include/forkserver.h
 src/afl-sharedmem.o : $(COMM_HDR) src/afl-sharedmem.c include/sharedmem.h
 	$(CC) $(CFLAGS) $(CFLAGS_FLTO) $(SPECIAL_PERFORMANCE) -c src/afl-sharedmem.c -o src/afl-sharedmem.o
 
-afl-fuzz: $(COMM_HDR) include/afl-fuzz.h $(AFL_FUZZ_FILES) src/afl-common.o src/afl-sharedmem.o src/afl-forkserver.o src/afl-performance.o | test_x86
-	$(CC) $(CFLAGS) $(COMPILE_STATIC) $(CFLAGS_FLTO) $(SPECIAL_PERFORMANCE) $(AFL_FUZZ_FILES) src/afl-common.o src/afl-sharedmem.o src/afl-forkserver.o src/afl-performance.o -o $@ $(PYFLAGS) $(LDFLAGS) -lm
+afl-ijon-min.o: $(COMM_HDR) src/afl-ijon-min.c
+	$(CC) $(CFLAGS) $(CFLAGS_FLTO) $(SPECIAL_PERFORMANCE) -c src/afl-ijon-min.c  -o src/afl-ijon-min.o
+
+afl-fuzz: $(COMM_HDR) include/afl-fuzz.h $(AFL_FUZZ_FILES) src/afl-common.o src/afl-sharedmem.o src/afl-forkserver.o src/afl-performance.o src/afl-ijon-min.o | test_x86
+	$(CC) $(CFLAGS) $(COMPILE_STATIC) $(CFLAGS_FLTO) $(SPECIAL_PERFORMANCE) $(AFL_FUZZ_FILES) src/afl-common.o src/afl-sharedmem.o src/afl-forkserver.o src/afl-performance.o src/afl-ijon-min.o -o $@ $(PYFLAGS) $(LDFLAGS) -lm
 
 afl-showmap: src/afl-showmap.c src/afl-common.o src/afl-sharedmem.o src/afl-forkserver.o src/afl-performance.o $(COMM_HDR) | test_x86
 	$(CC) $(CFLAGS) $(COMPILE_STATIC) $(CFLAGS_FLTO) $(SPECIAL_PERFORMANCE) src/$@.c src/afl-fuzz-mutators.c src/afl-fuzz-python.c src/afl-common.o src/afl-sharedmem.o src/afl-forkserver.o src/afl-performance.o -o $@ $(PYFLAGS) $(LDFLAGS)
diff --git a/include/afl-fuzz.h b/include/afl-fuzz.h
index 0f0e45d3..a5f5ebfa 100644
--- a/include/afl-fuzz.h
+++ b/include/afl-fuzz.h
@@ -45,6 +45,7 @@
 #include "sharedmem.h"
 #include "forkserver.h"
 #include "common.h"
+#include "afl-ijon-min.h"
 
 #include <stdio.h>
 #include <unistd.h>
@@ -545,6 +546,7 @@ typedef struct afl_state {
       *tmp_dir,                         /* Temporary directory for input    */
       *sync_dir,                        /* Synchronization directory        */
       *sync_id,                         /* Fuzzer ID                        */
+      *max_dir,                         /* Ijon Max directory               */
       *power_name,                      /* Power schedule name              */
       *use_banner,                      /* Display banner                   */
       *in_bitmap,                       /* Input bitmap                     */
@@ -608,6 +610,7 @@ typedef struct afl_state {
   u32     active_items;                 /* enabled entries in the queue     */
 
   u8 *var_bytes;                        /* Bytes that appear to be variable */
+  ijon_min_state* ijon_state;
 
 #define N_FUZZ_SIZE (1 << 21)
   u32 *n_fuzz;
diff --git a/include/afl-ijon-min.h b/include/afl-ijon-min.h
new file mode 100644
index 00000000..335f4cfd
--- /dev/null
+++ b/include/afl-ijon-min.h
@@ -0,0 +1,33 @@
+#ifndef _HAVE_IJON_MIN_H
+#define _HAVE_IJON_MIN_H
+
+#include "config.h"
+#define IJON_MAX_INPUT_SIZE (64*1024)
+
+typedef struct{
+  char* filename;
+  int slot_id;
+  size_t len;
+} ijon_input_info;
+
+
+typedef struct{
+  uint64_t max_map[MAXMAP_SIZE];
+  ijon_input_info* infos[MAXMAP_SIZE];
+  size_t num_entries;
+	size_t num_updates;
+  char* max_dir;
+  int schedule_prob;
+} ijon_min_state;
+
+
+ijon_min_state* new_ijon_min_state();
+
+u8 ijon_should_schedule(ijon_min_state* self);
+
+ijon_input_info* ijon_get_input(ijon_min_state* self);
+
+void ijon_update_max(ijon_min_state* self, shared_data_t* shared, uint8_t* data, size_t len);
+
+
+#endif
diff --git a/include/config.h b/include/config.h
index 7cb93ef8..e84a337f 100644
--- a/include/config.h
+++ b/include/config.h
@@ -26,7 +26,7 @@
 /* Version string: */
 
 // c = release, a = volatile github dev, e = experimental branch
-#define VERSION "++4.30c"
+#define VERSION "++4.30c-ijon"
 
 /******************************************************
  *                                                    *
@@ -219,13 +219,13 @@
    ranges has a 33% probability of getting picked, except for the first
    two cycles where smaller blocks are favored: */
 
-#define HAVOC_BLK_SMALL 32U
-#define HAVOC_BLK_MEDIUM 128U
-#define HAVOC_BLK_LARGE 1500U
+#define HAVOC_BLK_SMALL 8U
+#define HAVOC_BLK_MEDIUM 32U
+#define HAVOC_BLK_LARGE 512U
 
 /* Extra-large blocks, selected very rarely (<5% of the time): */
 
-#define HAVOC_BLK_XL 32768U
+#define HAVOC_BLK_XL 512U
 
 /* Probabilities of skipping non-favored entries in the queue, expressed as
    percentages: */
@@ -236,7 +236,7 @@
 
 /* Splicing cycle count: */
 
-#define SPLICE_CYCLES 15
+#define SPLICE_CYCLES 8
 
 /* Nominal per-splice havoc cycle length: */
 
@@ -408,6 +408,8 @@
 
 #define SHM_FUZZ_ENV_VAR "__AFL_SHM_FUZZ_ID"
 
+#define IJON_SHM_ENV_VAR "__AFL_IJON_SHM_ID"
+
 /* Other less interesting, internal-only variables. */
 
 #define CLANG_ENV_VAR "__AFL_CLANG_MODE"
@@ -464,12 +466,20 @@
 /* Do not change this unless you really know what you are doing. */
 
 #define MAP_SIZE (1U << MAP_SIZE_POW2)
+#define MAXMAP_SIZE (512)
 #if MAP_SIZE <= 2097152
   #define MAP_INITIAL_SIZE (2 << 20)  // = 2097152
 #else
   #define MAP_INITIAL_SIZE MAP_SIZE
 #endif
 
+typedef struct{
+  unsigned char afl_area[MAP_SIZE];
+  unsigned long int afl_max[MAXMAP_SIZE];
+  unsigned char is_selected;
+} shared_data_t;
+
+
 /* Maximum allocator request size (keep well under INT_MAX): */
 
 #define MAX_ALLOC 0x40000000
diff --git a/include/forkserver.h b/include/forkserver.h
index d3d0e086..a572694c 100644
--- a/include/forkserver.h
+++ b/include/forkserver.h
@@ -104,6 +104,7 @@ typedef struct afl_forkserver {
   /* a program that includes afl-forkserver needs to define these */
 
   u8 *trace_bits;                       /* SHM with instrumentation bitmap  */
+  u64 *ijon_max_bits;
 
   s32 fsrv_pid,                         /* PID of the fork server           */
       child_pid,                        /* PID of the fuzzed program        */
diff --git a/include/sharedmem.h b/include/sharedmem.h
index 036fa560..b7e8d6d9 100644
--- a/include/sharedmem.h
+++ b/include/sharedmem.h
@@ -44,6 +44,7 @@ typedef struct sharedmem {
 #else
   s32 shm_id;                          /* ID of the SHM region              */
   s32 cmplog_shm_id;
+  s32 ijon_shm_id;
 #endif
 
   u8 *map;                                          /* shared memory region */
@@ -54,6 +55,8 @@ typedef struct sharedmem {
   int             shmemfuzz_mode;
   struct cmp_map *cmp_map;
 
+  u64 *ijon_map;
+
 } sharedmem_t;
 
 u8  *afl_shm_init(sharedmem_t *, size_t, unsigned char non_instrumented_mode);
diff --git a/instrumentation/afl-compiler-rt.o.c b/instrumentation/afl-compiler-rt.o.c
index 77a9623c..8f7d23b0 100644
--- a/instrumentation/afl-compiler-rt.o.c
+++ b/instrumentation/afl-compiler-rt.o.c
@@ -33,6 +33,7 @@ __attribute__((weak)) void __sanitizer_symbolize_pc(void *, const char *fmt,
 #endif
 #include "config.h"
 #include "types.h"
+#include "afl-rt.h"
 #include "cmplog.h"
 #include "llvm-alternative-coverage.h"
 
@@ -48,6 +49,7 @@ __attribute__((weak)) void __sanitizer_symbolize_pc(void *, const char *fmt,
 #include <assert.h>
 #include <stdint.h>
 #include <stddef.h>
+#include <execinfo.h>
 #include <limits.h>
 #include <errno.h>
 
@@ -106,6 +108,9 @@ static u8  __afl_area_initial[MAP_INITIAL_SIZE];
 static u8 *__afl_area_ptr_dummy = __afl_area_initial;
 static u8 *__afl_area_ptr_backup = __afl_area_initial;
 
+uint64_t __afl_max_initial[MAXMAP_SIZE];
+uint64_t *__afl_max_ptr = __afl_max_initial;
+
 u8        *__afl_area_ptr = __afl_area_initial;
 u8        *__afl_dictionary;
 u8        *__afl_fuzz_ptr;
@@ -188,6 +193,10 @@ __thread PREV_LOC_T __afl_prev_caller[CTX_MAX_K];
 __thread u32        __afl_prev_ctx;
 #endif
 
+__thread u32 __afl_state;
+__thread u32 __afl_state_log;
+__thread u32 __afl_mask = 0xffffffff;
+
 struct cmp_map *__afl_cmp_map;
 struct cmp_map *__afl_cmp_map_backup;
 
@@ -223,6 +232,110 @@ u32 __afl_already_initialized_init;
 
 static int __afl_dummy_fd[2] = {2, 2};
 
+void ijon_xor_state(uint32_t val){
+  __afl_state = (__afl_state^val)%MAP_SIZE;
+}
+
+void ijon_push_state(uint32_t x){
+  ijon_xor_state(__afl_state_log);
+  __afl_state_log = (__afl_state_log << 8) | (x & 0xff);
+  ijon_xor_state(__afl_state_log);
+}
+
+void ijon_max(uint32_t addr, uint64_t val){
+  if(__afl_max_ptr[addr%MAXMAP_SIZE] < val) {
+    __afl_max_ptr[addr%MAXMAP_SIZE] = val;
+  }
+}
+
+void ijon_min(uint32_t addr, uint64_t val){
+  val = 0xffffffffffffffff-val;
+  ijon_max(addr, val);
+}
+
+
+void ijon_map_inc(uint32_t addr){
+  __afl_area_ptr[(__afl_state^addr)%MAP_SIZE]+=1;
+}
+
+void ijon_map_set(uint32_t addr){
+  __afl_area_ptr[(__afl_state^addr)%MAP_SIZE]|=1;
+}
+
+uint32_t ijon_strdist(char* a,char* b){
+  int i = 0;
+  while(a && b && *a && *b && *a++==*b++){
+    i++;
+  }
+  return i;
+}
+
+uint32_t ijon_memdist(char* a,char* b, size_t len){
+  int i = 0;
+  while(i < len && *a++==*b++){
+    i++;
+  }
+  return i;
+}
+
+uint64_t ijon_simple_hash(uint64_t x) {
+    x = (x ^ (x >> 30)) * UINT64_C(0xbf58476d1ce4e5b9);
+    x = (x ^ (x >> 27)) * UINT64_C(0x94d049bb133111eb);
+    x = x ^ (x >> 31);
+    return x;
+}
+
+void ijon_enable_feedback(){
+	__afl_mask = 0xffffffff;
+}
+void ijon_disable_feedback(){
+	__afl_mask = 0x0;
+}
+
+uint32_t ijon_hashint(uint32_t old, uint32_t val){
+  uint64_t input = (((uint64_t)(old))<<32) | ((uint64_t)(val));
+  return (uint32_t)(ijon_simple_hash(input));
+}
+uint32_t ijon_hashstr(uint32_t old, char* val){
+  return ijon_hashmem(old, val, strlen(val));
+}
+uint32_t ijon_hashmem(uint32_t old, char* val, size_t len){
+  old = ijon_hashint(old,len);
+  for(size_t i = 0; i < len ; i++){
+    old = ijon_hashint(old, val[i]);
+  }
+  return old;
+}
+#ifdef __i386__
+//WHY IS STACKUNWINDING NOT WORKING IN CGC BINARIES?
+uint32_t ijon_hashstack_manual(){
+	uint32_t *ebp=0;
+	uint64_t res = 0;
+	asm("\t movl %%ebp,%0" : "=r"(ebp));
+	for(int i=0; i<16 && ebp; i++){
+		//printf("ebp: %p\n", ebp);
+		printf("ret: %x\n", ebp[1]);
+		res ^= ijon_simple_hash((uint64_t)ebp[1]);
+		ebp = (uint32_t*)ebp[0];
+	}
+ printf(">>>> Final Stackhash: %lx\n",res);
+	return (uint32_t)res;
+}
+#endif
+
+uint32_t ijon_hashstack_libgcc(){
+ void* buffer[16] = {0,};
+ int num = backtrace (buffer, 16);
+ // assert(num<16);
+ uint64_t res = 0;
+ for(int i =0; i < num; i++) {
+	 printf("stack_frame %p\n", buffer[i]);
+	 res ^= ijon_simple_hash((uint64_t)buffer[i]);
+ }
+ printf(">>>> Final Stackhash: %lx\n",res);
+ return (uint32_t)res;
+}
+
 /* ensure we kill the child on termination */
 
 static void at_exit(int signal) {
@@ -552,19 +665,14 @@ static void __afl_map_shm(void) {
     }
 
     __afl_area_ptr = (u8 *)shmat(shm_id, (void *)__afl_map_addr, 0);
-
-    /* Whooooops. */
-
     if (!__afl_area_ptr || __afl_area_ptr == (void *)-1) {
-
       if (__afl_map_addr)
         send_forkserver_error(FS_ERROR_MAP_ADDR);
       else
         send_forkserver_error(FS_ERROR_SHMAT);
 
       perror("shmat for map");
-      _exit(1);
-
+      exit(1);
     }
 
 #endif
@@ -656,6 +764,34 @@ static void __afl_map_shm(void) {
 
   }
 
+  id_str = getenv(IJON_SHM_ENV_VAR);
+
+  if (__afl_debug) {
+    fprintf(stderr, "DEBUG: ijon id_str %s\n",
+            id_str == NULL ? "<null>" : id_str);
+
+  }
+
+  if (id_str) {
+#ifdef USEMMAP
+    // Crash and burn
+    assert(0);
+#else
+    u32 shm_id = atoi(id_str);
+    __afl_max_ptr = (u64 *)shmat(shm_id, NULL, 0);
+
+    if (!__afl_max_ptr || __afl_max_ptr == (void *)-1) {
+      perror("shmat for max");
+      send_forkserver_error(FS_ERROR_SHMAT);
+      _exit(1);
+    }
+#endif
+  }
+
+  if (__afl_debug) {
+    fprintf(stderr, "DEBUG: ijon max_ptr %p\n", __afl_max_ptr);
+  }
+
   id_str = getenv(CMPLOG_SHM_ENV_VAR);
 
   if (__afl_debug) {
@@ -1125,8 +1261,12 @@ int __afl_persistent_loop(unsigned int max_cnt) {
        before the loop. */
 
     memset(__afl_area_ptr, 0, __afl_map_size);
+    memset(__afl_max_ptr, 0, MAXMAP_SIZE * sizeof(uint64_t));
     __afl_area_ptr[0] = 1;
     memset(__afl_prev_loc, 0, NGRAM_SIZE_MAX * sizeof(PREV_LOC_T));
+    __afl_state = 0;
+    __afl_mask = 0xffffffff;
+    __afl_state_log = 0;
 
     first_pass = 0;
     __afl_selective_coverage_temp = 1;
@@ -1185,6 +1325,9 @@ int __afl_persistent_loop(unsigned int max_cnt) {
 
     __afl_area_ptr[0] = 1;
     memset(__afl_prev_loc, 0, NGRAM_SIZE_MAX * sizeof(PREV_LOC_T));
+    __afl_state = 0;
+    __afl_mask = 0xffffffff;
+    __afl_state_log = 0;
     __afl_selective_coverage_temp = 1;
 
     return 1;
diff --git a/instrumentation/afl-llvm-pass.so.cc b/instrumentation/afl-llvm-pass.so.cc
index 8620fb3f..18076513 100644
--- a/instrumentation/afl-llvm-pass.so.cc
+++ b/instrumentation/afl-llvm-pass.so.cc
@@ -254,6 +254,9 @@ bool AFLCoverage::runOnModule(Module &M) {
       FATAL("Bad value of AFL_INST_RATIO (must be between 1 and 100)");
 
   }
+  // if (inst_ratio == 1) {
+  //   inst_ratio = 0;
+  // }
 
 #if LLVM_VERSION_MAJOR < 9
   char *neverZero_counters_str = getenv("AFL_LLVM_NOT_ZERO");
@@ -404,15 +407,27 @@ bool AFLCoverage::runOnModule(Module &M) {
   GlobalVariable *AFLPrevLoc;
   GlobalVariable *AFLPrevCaller;
   GlobalVariable *AFLContext = NULL;
+  GlobalVariable *AFLState = NULL;
+  GlobalVariable *AFLMask = NULL;
 
   if (ctx_str || caller_str)
 #if defined(__ANDROID__) || defined(__HAIKU__) || defined(NO_TLS)
     AFLContext = new GlobalVariable(
         M, Int32Ty, false, GlobalValue::ExternalLinkage, 0, "__afl_prev_ctx");
+    AFLState = new GlobalVariable(
+        M, Int32Ty, false, GlobalValue::ExternalLinkage, 0, "__afl_state");
+    AFLMask = new GlobalVariable(
+        M, Int32Ty, false, GlobalValue::ExternalLinkage, 0, "__afl_mask");
 #else
     AFLContext = new GlobalVariable(
         M, Int32Ty, false, GlobalValue::ExternalLinkage, 0, "__afl_prev_ctx", 0,
         GlobalVariable::GeneralDynamicTLSModel, 0, false);
+    AFLState = new GlobalVariable(
+        M, Int32Ty, false, GlobalValue::ExternalLinkage, 0, "__afl_state", 0,
+        GlobalVariable::GeneralDynamicTLSModel, 0, false);
+    AFLMask = new GlobalVariable(
+        M, Int32Ty, false, GlobalValue::ExternalLinkage, 0, "__afl_mask", 0,
+        GlobalVariable::GeneralDynamicTLSModel, 0, false);
 #endif
 
 #ifdef AFL_HAVE_VECTOR_INTRINSICS
@@ -702,7 +717,27 @@ bool AFLCoverage::runOnModule(Module &M) {
 #endif
         CurLoc = ConstantInt::get(Int32Ty, cur_loc);
 
-      /* Load prev_loc */
+      /* Load __afl_mask */
+
+      LoadInst *Mask = IRB.CreateLoad(
+#if LLVM_VERSION_MAJOR >= 14
+        IRB.getInt32Ty(),
+#endif
+        AFLMask);
+      Mask->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
+      Value *MaskCasted = IRB.CreateZExt(Mask, IRB.getInt32Ty());
+
+      /* Load __afl_state */
+
+      LoadInst *State = IRB.CreateLoad(
+#if LLVM_VERSION_MAJOR >= 14
+        IRB.getInt32Ty(),
+#endif
+        AFLState);
+      State->setMetadata(M.getMDKindID("nosanitize"), MDNode::get(C, None));
+      Value *StateCasted = IRB.CreateZExt(State, IRB.getInt32Ty());
+
+     /* Load prev_loc */
 
       LoadInst *PrevLoc;
 
@@ -768,7 +803,7 @@ bool AFLCoverage::runOnModule(Module &M) {
 #if LLVM_VERSION_MAJOR >= 14
             Int8Ty,
 #endif
-            MapPtr, IRB.CreateXor(PrevLocTrans, CurLoc));
+            MapPtr, IRB.CreateAnd(MaskCasted, IRB.CreateXor(StateCasted, IRB.CreateXor(PrevLocTrans, CurLoc))));
 
       /* Update bitmap */
 
diff --git a/instrumentation/afl-rt.h b/instrumentation/afl-rt.h
new file mode 100644
index 00000000..165d3a07
--- /dev/null
+++ b/instrumentation/afl-rt.h
@@ -0,0 +1,68 @@
+#pragma once
+#ifndef _NO_IJON_IN_ASM
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+typedef __INT8_TYPE__  ijon_i8_t;
+typedef __INT16_TYPE__ ijon_i16_t;
+typedef __INT32_TYPE__ ijon_i32_t;
+typedef __INT64_TYPE__ ijon_i64_t;
+
+typedef __UINT8_TYPE__  ijon_u8_t;
+typedef __UINT16_TYPE__ ijon_u16_t;
+typedef __UINT32_TYPE__ ijon_u32_t;
+typedef __UINT64_TYPE__ ijon_u64_t;
+
+typedef __SIZE_TYPE__   ijon_size_t;
+
+void ijon_xor_state(ijon_u32_t);
+
+void ijon_push_state(ijon_u32_t);
+
+void ijon_map_inc(ijon_u32_t);
+void ijon_map_set(ijon_u32_t);
+
+ijon_u32_t ijon_strdist(char* a,char* b);
+ijon_u32_t ijon_memdist(char* a,char* b, ijon_size_t len);
+
+void ijon_max(ijon_u32_t addr, ijon_u64_t val);
+
+void ijon_min(ijon_u32_t addr, ijon_u64_t val);
+
+ijon_u64_t ijon_simple_hash(ijon_u64_t val);
+ijon_u32_t ijon_hashint(ijon_u32_t old, ijon_u32_t val);
+ijon_u32_t ijon_hashstr(ijon_u32_t old, char* val);
+ijon_u32_t ijon_hashmem(ijon_u32_t old, char* val, ijon_size_t len);
+
+#ifdef _IJON_CGC
+ijon_u32_t ijon_hashstack_manual();
+#define ijon_hashstack() ijon_hashstack_manual()
+#else
+ijon_u32_t ijon_hashstack_libgcc();
+#define ijon_hashstack() ijon_hashstack_libgcc()
+#endif
+
+void ijon_enable_feedback();
+void ijon_disable_feedback();
+
+#define _IJON_CONCAT(x, y) x##y
+#define _IJON_UNIQ_NAME() IJON_CONCAT(temp,__LINE__)
+#define _IJON_ABS_DIST(x,y) ((x)<(y) ? (y)-(x) : (x)-(y))
+
+#define IJON_BITS(x) ((x)==0 ? 0 : __builtin_clz(x))
+#define IJON_INC(x) ijon_map_inc(ijon_hashstr(__LINE__,__FILE__)^(unsigned int)(x))
+#define IJON_SET(x) ijon_map_set(ijon_hashstr(__LINE__,__FILE__)^(unsigned int)(x))
+
+#define IJON_CTX(x) ({ ijon_u32_t hash = ijon_hashstr(__LINE__,__FILE__); ijon_xor_state(hash); __typeof__(x) _tmp = (x); ijon_xor_state(hash); _tmp; })
+
+#define IJON_MAX(x) ijon_max(ijon_hashstr(__LINE__,__FILE__),(unsigned long long)(x))
+#define IJON_MIN(x) ijon_min(ijon_hashstr(__LINE__,__FILE__), 0xffffffffffffffffULL - (unsigned long long)(x))
+#define IJON_CMP(x,y) IJON_INC(__builtin_popcountll((unsigned long long)(x)^(unsigned long long)(y)))
+#define IJON_DIST(x,y) ijon_min(ijon_hashstr(__LINE__,__FILE__), _IJON_ABS_DIST((long long)x,(long long)y))
+#define IJON_STRDIST(x,y) IJON_SET(ijon_hashint(ijon_hashstack(), ijon_strdist(x,y)))
+
+#if defined(__cplusplus)
+}
+#endif
+#endif
diff --git a/src/afl-cc.c b/src/afl-cc.c
index 11e61fab..cd970c32 100644
--- a/src/afl-cc.c
+++ b/src/afl-cc.c
@@ -602,6 +602,7 @@ void compiler_mode_by_callname(aflcc_state_t *aflcc) {
   if (strncmp(aflcc->callname, "afl-clang-fast", 14) == 0) {
 
     /* afl-clang-fast is always created there by makefile
+      just like afl-clang, burdened with special purposes:
       - If llvm-config is not available (i.e. LLVM_MAJOR is 0),
         or too old, it falls back to LLVM-NATIVE mode and let
         the actual compiler complain if doesn't work.
@@ -1219,8 +1220,11 @@ void mode_final_checkout(aflcc_state_t *aflcc, int argc, char **argv) {
   switch (aflcc->compiler_mode) {
 
     case GCC:
+      if (!aflcc->have_gcc) FATAL("afl-gcc is not available on your platform!");
       break;
     case CLANG:
+      if (!aflcc->have_clang)
+        FATAL("afl-clang is not available on your platform!");
       break;
     case LLVM:
       if (!aflcc->have_llvm)
@@ -1560,6 +1564,7 @@ void add_defs_selective_instr(aflcc_state_t *aflcc) {
 /*
   Macro defs for persistent mode. As documented in
   instrumentation/README.persistent_mode.md, deferred forkserver initialization
+  and persistent mode are not available in afl-gcc and afl-clang.
 */
 void add_defs_persistent_mode(aflcc_state_t *aflcc) {
 
@@ -1940,25 +1945,22 @@ void add_sanitizers(aflcc_state_t *aflcc, char **envp) {
 
   if (getenv("AFL_USE_UBSAN") || aflcc->have_ubsan) {
 
-    if (!aflcc->have_ubsan) { insert_param(aflcc, "-fsanitize=undefined"); }
+    if (!aflcc->have_ubsan) {
 
-    if (getenv("AFL_UBSAN_VERBOSE")) {
-
-      insert_param(aflcc, "-fno-sanitize-recover=undefined");
-
-    } else {
-
-      insert_param(aflcc, "-fsanitize-trap=undefined");
+      insert_param(aflcc, "-fsanitize=undefined");
+      insert_param(aflcc, "-fno-sanitize-recover=all");
 
     }
 
-    if (!aflcc->have_fp) {
+    if (true) {
 
       insert_param(aflcc, "-fno-omit-frame-pointer");
       aflcc->have_fp = 1;
 
     }
 
+    insert_param(aflcc, "-rdynamic");
+
     aflcc->have_ubsan = 1;
 
   }
@@ -2009,12 +2011,6 @@ void add_sanitizers(aflcc_state_t *aflcc, char **envp) {
 
       if (!aflcc->have_cfisan) { insert_param(aflcc, "-fsanitize=cfi"); }
 
-      if (getenv("AFL_CFISAN_VERBOSE")) {
-
-        insert_param(aflcc, "-fno-sanitize-trap=cfi");
-
-      }
-
       if (!aflcc->have_hidden) {
 
         insert_param(aflcc, "-fvisibility=hidden");
@@ -2647,6 +2643,7 @@ void add_misc_params(aflcc_state_t *aflcc) {
 
   }
 
+  insert_param(aflcc, alloc_printf("-include%s/instrumentation/afl-rt.h", getenv("AFL_PATH")));
 }
 
 /*
@@ -2851,7 +2848,10 @@ static void maybe_usage(aflcc_state_t *aflcc, int argc, char **argv) {
         "   yes\n"
         "  [GCC_PLUGIN] gcc plugin: %s%s\n"
         "      CLASSIC              DEFAULT      no  yes     no     no  no     "
-        "yes\n\n",
+        "yes\n"
+        "  [GCC/CLANG] simple gcc/clang: %s%s\n"
+        "      CLASSIC              DEFAULT      no  no      no     no  no     "
+        "no\n\n",
         aflcc->have_llvm ? "AVAILABLE   " : "unavailable!",
         aflcc->compiler_mode == LLVM ? " [SELECTED]" : "",
         aflcc->have_llvm ? "AVAILABLE   " : "unavailable!",
@@ -2859,7 +2859,15 @@ static void maybe_usage(aflcc_state_t *aflcc, int argc, char **argv) {
         aflcc->have_lto ? "AVAILABLE" : "unavailable!",
         aflcc->compiler_mode == LTO ? " [SELECTED]" : "",
         aflcc->have_gcc_plugin ? "AVAILABLE" : "unavailable!",
-        aflcc->compiler_mode == GCC_PLUGIN ? " [SELECTED]" : "");
+        aflcc->compiler_mode == GCC_PLUGIN ? " [SELECTED]" : "",
+        aflcc->have_gcc && aflcc->have_clang
+            ? "AVAILABLE"
+            : (aflcc->have_gcc
+                   ? "GCC ONLY "
+                   : (aflcc->have_clang ? "CLANG ONLY" : "unavailable!")),
+        (aflcc->compiler_mode == GCC || aflcc->compiler_mode == CLANG)
+            ? " [SELECTED]"
+            : "");
 
     SAYF(
         "Modes:\n"
@@ -3509,6 +3517,9 @@ static void edit_params(aflcc_state_t *aflcc, u32 argc, char **argv,
 
   }
 
+  if (getenv("AFL_RENAME_MAIN")) {
+    load_llvm_pass(aflcc, "afl-new-pass.so");
+  }
   /* Inspect the command line parameters. */
 
   process_params(aflcc, 0, argc, argv);
@@ -3549,27 +3560,15 @@ int main(int argc, char **argv, char **envp) {
 
   maybe_usage(aflcc, argc, argv);
 
-  if (aflcc->instrument_mode == INSTRUMENT_GCC ||
-      aflcc->instrument_mode == INSTRUMENT_CLANG) {
-
-    FATAL(
-        "afl-gcc/afl-clang are obsolete and has been removed. Use "
-        "afl-clang-fast/afl-gcc-fast for instrumentation instead.");
-
-  }
-
   mode_notification(aflcc);
 
   if (aflcc->debug) debugf_args(argc, argv);
 
   edit_params(aflcc, argc, argv, envp);
 
-  if (aflcc->debug) {
-
+  if (aflcc->debug)
     debugf_args((s32)aflcc->cc_par_cnt, (char **)aflcc->cc_params);
 
-  }
-
   if (aflcc->passthrough) {
 
     argv[0] = aflcc->cc_params[0];
diff --git a/src/afl-fuzz-bitmap.c b/src/afl-fuzz-bitmap.c
index fd75a822..8c4a9e1d 100644
--- a/src/afl-fuzz-bitmap.c
+++ b/src/afl-fuzz-bitmap.c
@@ -25,6 +25,7 @@
 
 #include "afl-fuzz.h"
 #include <limits.h>
+#include "afl-ijon-min.h"
 #if !defined NAME_MAX
   #define NAME_MAX _XOPEN_NAME_MAX
 #endif
@@ -505,6 +506,8 @@ u8 __attribute__((hot)) save_if_interesting(afl_state_t *afl, void *mem,
 
   if (likely(fault == afl->crash_mode)) {
 
+		ijon_update_max(afl->ijon_state, afl->shm.ijon_map, mem, len);
+
     /* Keep only if there are new bits in the map, add to queue for
        future fuzzing, etc. */
 
diff --git a/src/afl-fuzz-init.c b/src/afl-fuzz-init.c
index e90495f3..b5bad8e9 100644
--- a/src/afl-fuzz-init.c
+++ b/src/afl-fuzz-init.c
@@ -2241,6 +2241,9 @@ void setup_dirs_fds(afl_state_t *afl) {
 
   }
 
+  if (mkdir(afl->max_dir, 0700) && errno != EEXIST)
+    PFATAL("Unable to create '%s'", afl->max_dir);
+
   /* Queue directory for any starting & discovered paths. */
 
   tmp = alloc_printf("%s/queue", afl->out_dir);
diff --git a/src/afl-fuzz-one.c b/src/afl-fuzz-one.c
index fd5ed87c..b17b4f1e 100644
--- a/src/afl-fuzz-one.c
+++ b/src/afl-fuzz-one.c
@@ -326,7 +326,7 @@ static void locate_diffs(u8 *ptr1, u8 *ptr2, u32 len, s32 *first, s32 *last) {
 
 u8 fuzz_one_original(afl_state_t *afl) {
 
-  u32 len, temp_len;
+  u32 len, orig_len, temp_len;
   u32 j;
   u32 i;
   u8 *in_buf, *out_buf, *orig_in, *ex_tmp;
@@ -335,6 +335,8 @@ u8 fuzz_one_original(afl_state_t *afl) {
 
   u8 ret_val = 1, doing_det = 0;
 
+  u8 is_doing_ijon = 0;
+
   u8  a_collect[MAX_AUTO_EXTRA];
   u32 a_len = 0;
 
@@ -3350,7 +3352,7 @@ retry_splicing:
     if (in_buf != orig_in) {
 
       in_buf = orig_in;
-      len = afl->queue_cur->len;
+      len = orig_len;
 
     }
 
@@ -3429,19 +3431,21 @@ abandon_entry:
   /* Update afl->pending_not_fuzzed count if we made it through the calibration
      cycle and have not seen this entry before. */
 
-  if (!afl->stop_soon && !afl->queue_cur->cal_failed &&
-      !afl->queue_cur->was_fuzzed && !afl->queue_cur->disabled) {
+  if (!is_doing_ijon){
+    if (!afl->stop_soon && !afl->queue_cur->cal_failed &&
+        !afl->queue_cur->was_fuzzed && !afl->queue_cur->disabled) {
 
-    --afl->pending_not_fuzzed;
-    afl->queue_cur->was_fuzzed = 1;
-    afl->reinit_table = 1;
-    if (afl->queue_cur->favored) {
+      --afl->pending_not_fuzzed;
+      afl->queue_cur->was_fuzzed = 1;
+      afl->reinit_table = 1;
+      if (afl->queue_cur->favored) {
 
-      --afl->pending_favored;
-      afl->smallest_favored = -1;
+        --afl->pending_favored;
+        afl->smallest_favored = -1;
 
-    }
+      }
 
+    }
   }
 
   ++afl->queue_cur->fuzz_level;
@@ -3466,7 +3470,7 @@ static u8 mopt_common_fuzzing(afl_state_t *afl, MOpt_globals_t MOpt_globals) {
 
   }
 
-  u32 len, temp_len;
+  u32 len, orig_len, fd, temp_len;
   u32 i;
   u32 j;
   u8 *in_buf, *out_buf, *orig_in, *ex_tmp, *eff_map = 0;
@@ -3476,6 +3480,8 @@ static u8 mopt_common_fuzzing(afl_state_t *afl, MOpt_globals_t MOpt_globals) {
 
   u8 ret_val = 1, doing_det = 0;
 
+  u8 is_doing_ijon = 0;
+
   u8  a_collect[MAX_AUTO_EXTRA];
   u32 a_len = 0;
 
@@ -3532,15 +3538,41 @@ static u8 mopt_common_fuzzing(afl_state_t *afl, MOpt_globals_t MOpt_globals) {
   }
 
   /* Map the test case into memory. */
-  orig_in = in_buf = queue_testcase_get(afl, afl->queue_cur);
-  len = afl->queue_cur->len;
 
-  out_buf = afl_realloc(AFL_BUF_PARAM(out), len);
-  if (unlikely(!out_buf)) { PFATAL("alloc"); }
+  if(ijon_should_schedule(afl->ijon_state)){
+    ijon_input_info* info = ijon_get_input(afl->ijon_state);
+    fd = open(info->filename, O_RDONLY);
+    if (fd < 0) { PFATAL("Unable to open '%s'", info->filename); }
+
+    len = info->len;
+    orig_len = len;
+
+    orig_in = in_buf = mmap(0, len, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
+    if (orig_in == MAP_FAILED) { PFATAL("Unable to mmap '%s'", info->filename); }
+
+    close(fd);
+    out_buf = afl_realloc(AFL_BUF_PARAM(out), len);
+    if (unlikely(!out_buf)) { PFATAL("alloc"); }
+    memcpy(out_buf, in_buf, len);
+
+    is_doing_ijon = 1;
+    orig_perf = perf_score = 100;
+
+    goto havoc_stage;
+  } else {
+    orig_in = in_buf = queue_testcase_get(afl, afl->queue_cur);
+    len = afl->queue_cur->len;
+    orig_len = len;
+    out_buf = afl_realloc(AFL_BUF_PARAM(out), len);
+    if (unlikely(!out_buf)) { PFATAL("alloc"); }
+
+    afl->subseq_tmouts = 0;
+    afl->cur_depth = afl->queue_cur->depth;
+
+    is_doing_ijon = 0;
+  }
 
-  afl->subseq_tmouts = 0;
 
-  afl->cur_depth = afl->queue_cur->depth;
 
   /*******************************************
    * CALIBRATION (only if failed earlier on) *
@@ -5043,10 +5075,15 @@ pacemaker_fuzzing:
                  MOpt_globals.splice_stageformat, splice_cycle);
         afl->stage_name = afl->stage_name_buf;
         afl->stage_short = MOpt_globals.splice_stagenameshort;
-        afl->stage_max = SPLICE_HAVOC * perf_score / afl->havoc_div / 100;
+        afl->stage_max = SPLICE_HAVOC * perf_score / afl->havoc_div / 200;
 
       }
 
+      if (is_doing_ijon) {
+        afl->stage_name = "ijon-max";
+        afl->stage_short = "ijon-max";
+      }
+
       if (afl->stage_max < HAVOC_MIN) { afl->stage_max = HAVOC_MIN; }
 
       temp_len = len;
@@ -5364,6 +5401,7 @@ pacemaker_fuzzing:
               /* Delete bytes. We're making this a bit more likely
                  than insertion (the next option) in hopes of keeping
                  files reasonably small. */
+              break;
 
               u32 del_from, del_len;
 
@@ -5566,8 +5604,7 @@ pacemaker_fuzzing:
 
               else if (r == 1 && (afl->extras_cnt || afl->a_extras_cnt)) {
 
-                u32 use_extra, extra_len,
-                    insert_at = rand_below(afl, temp_len + 1);
+                u32 use_extra, extra_len, insert_at = temp_len; //rand_below(afl, temp_len + 1);
                 u8 *ptr;
 
                 /* Insert an extra. Do the same dice-rolling stuff as for the
diff --git a/src/afl-fuzz.c b/src/afl-fuzz.c
index b7f99ddc..23dbbb5b 100644
--- a/src/afl-fuzz.c
+++ b/src/afl-fuzz.c
@@ -912,13 +912,13 @@ int main(int argc, char **argv_orig, char **envp) {
       case 'F':                                         /* foreign sync dir */
 
         if (!optarg) { FATAL("Missing path for -F"); }
-        if (!afl->is_main_node) {
+        // if (!afl->is_main_node) {
 
-          FATAL(
-              "Option -F can only be specified after the -M option for the "
-              "main fuzzer of a fuzzing campaign");
+        //   FATAL(
+        //       "Option -F can only be specified after the -M option for the "
+        //       "main fuzzer of a fuzzing campaign");
 
-        }
+        // }
 
         if (afl->foreign_sync_cnt >= FOREIGN_SYNCS_MAX) {
 
@@ -1637,6 +1637,8 @@ int main(int argc, char **argv_orig, char **envp) {
 
   }
 
+  assert(asprintf(&afl->max_dir, "%s/ijon_max", afl->out_dir) > 0);
+
   if (afl->non_instrumented_mode) {
 
     if (afl->crash_mode) { FATAL("-C and -n are mutually exclusive"); }
@@ -2021,6 +2023,7 @@ int main(int argc, char **argv_orig, char **envp) {
   atexit(at_exit);
 
   setup_dirs_fds(afl);
+  afl->ijon_state = new_ijon_min_state(afl->max_dir);
 
   #ifdef HAVE_AFFINITY
   bind_to_free_cpu(afl);
diff --git a/src/afl-ijon-min.c b/src/afl-ijon-min.c
new file mode 100644
index 00000000..5ed770e9
--- /dev/null
+++ b/src/afl-ijon-min.c
@@ -0,0 +1,85 @@
+#include <string.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <assert.h>
+#include <time.h>
+
+#include "types.h"
+#include "afl-ijon-min.h"
+
+ijon_input_info* new_ijon_input_info(char* max_dir, int i){
+  ijon_input_info* self = malloc(sizeof(ijon_input_info));
+  self->filename = (char *) malloc(strlen(max_dir)+12);
+  assert(sprintf(self->filename,"%s/%d", max_dir, i) > 0);
+  self->slot_id = i;
+	self->len = 0;
+  return self;
+}
+
+ijon_min_state* new_ijon_min_state(char* max_dir) {
+  ijon_min_state* self = malloc(sizeof(ijon_min_state));
+  self->max_dir = max_dir;
+  self->num_entries = 0;
+	self->num_updates = 0;
+  for(int i = 0; i< MAXMAP_SIZE; i++){
+    self->max_map[i] = 0;
+    self->infos[i]=new_ijon_input_info(max_dir, i);
+  }
+  return self;
+}
+
+
+u8 ijon_should_schedule(ijon_min_state* self){
+  if(self->num_entries > 0){
+    return random()%100 > 20;
+  }
+  return 0;
+}
+
+ijon_input_info* ijon_get_input(ijon_min_state* self){
+  uint32_t rnd = random()%self->num_entries;
+  for(int i = 0; i<MAXMAP_SIZE; i++){
+    if(self->max_map[i]>0){
+      if(rnd==0){
+        printf("schedule: %i %s\n",i, self->infos[i]->filename);
+        return self->infos[i];
+      }
+      rnd-=1;
+    }
+  }
+  return 0;
+}
+
+void ijon_store_max_input(ijon_min_state* self, int i, uint8_t* data, size_t len){
+  ijon_input_info* inf = self->infos[i];
+  inf->len = len;
+  int fd = open(inf->filename, O_CREAT|O_TRUNC|O_WRONLY,0600);
+  assert(write(fd,data,len) == len);
+  close(fd);
+
+	char* filename = (char*) malloc(strlen(self->max_dir)+100);
+	assert(sprintf(filename, "%s/finding_%lu_%lu", self->max_dir, self->num_updates, time(0)) > 0);
+	self->num_updates+=1;
+  fd = open(filename, O_CREAT|O_TRUNC|O_WRONLY,0600);
+  assert(write(fd,data,len) == len);
+  close(fd);
+	free(filename);
+}
+
+void ijon_update_max(ijon_min_state* self, shared_data_t* shared, uint8_t* data, size_t len){
+	int should_min = (len>512);
+  for(int i=0; i<MAXMAP_SIZE; i++){
+    if(shared->afl_max[i] > self->max_map[i]){
+      if(self->max_map[i]==0){ // found an input that triggers a new slot
+        self->num_entries++;
+      }
+      self->max_map[i] = shared->afl_max[i];
+      printf("updated maxmap %d: %lx (len: %ld)\n", i, self->max_map[i], len);
+      ijon_store_max_input(self, i, data, len);
+    }else if(should_min && (shared->afl_max[i] == self->max_map[i] ) && ( len < self->infos[i]->len) ){
+      printf("minimized maxmap %d: %lx (len: %ld)\n", i, self->max_map[i], len);
+			ijon_store_max_input(self,i,data,len);
+		}
+  }
+}
diff --git a/src/afl-sharedmem.c b/src/afl-sharedmem.c
index 1dea83f9..7de6c2d9 100644
--- a/src/afl-sharedmem.c
+++ b/src/afl-sharedmem.c
@@ -285,6 +285,14 @@ u8 *afl_shm_init(sharedmem_t *shm, size_t map_size,
 
   }
 
+  u8 *ijon_shm_str;
+
+  shm->ijon_shm_id = shmget(IPC_PRIVATE, map_size, IPC_CREAT | IPC_EXCL | DEFAULT_PERMISSION);
+  if (shm->ijon_shm_id < 0) {
+    shmctl(shm->shm_id, IPC_RMID, NULL);
+    PFATAL("shmget() failed for ijon");
+  }
+
   if (shm->cmplog_mode) {
 
     shm->cmplog_shm_id = shmget(IPC_PRIVATE, sizeof(struct cmp_map),
@@ -302,6 +310,7 @@ u8 *afl_shm_init(sharedmem_t *shm, size_t map_size,
   if (!non_instrumented_mode) {
 
     shm_str = alloc_printf("%d", shm->shm_id);
+    ijon_shm_str = alloc_printf("%d", shm->ijon_shm_id);
 
     /* If somebody is asking us to fuzz instrumented binaries in
        non-instrumented mode, we don't want them to detect instrumentation,
@@ -309,6 +318,7 @@ u8 *afl_shm_init(sharedmem_t *shm, size_t map_size,
        with better auto-detection later on, perhaps? */
 
     setenv(SHM_ENV_VAR, shm_str, 1);
+    setenv(IJON_SHM_ENV_VAR, ijon_shm_str, 1);
 
     ck_free(shm_str);
 
@@ -340,6 +350,23 @@ u8 *afl_shm_init(sharedmem_t *shm, size_t map_size,
 
   }
 
+  shm->ijon_map = shmat(shm->ijon_shm_id, NULL, 0);
+
+  if (shm->ijon_map == (void *)-1 || !shm->ijon_map) {
+
+    shmctl(shm->shm_id, IPC_RMID, NULL);  // do not leak shmem
+    shmctl(shm->ijon_shm_id, IPC_RMID, NULL);  // do not leak shmem
+
+    if (shm->cmplog_mode) {
+
+      shmctl(shm->cmplog_shm_id, IPC_RMID, NULL);  // do not leak shmem
+
+    }
+
+    PFATAL("shmat() failed");
+
+  }
+
   if (shm->cmplog_mode) {
 
     shm->cmp_map = shmat(shm->cmplog_shm_id, NULL, 0);
