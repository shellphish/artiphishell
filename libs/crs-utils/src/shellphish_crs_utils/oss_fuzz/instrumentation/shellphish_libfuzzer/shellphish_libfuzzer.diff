# Comment by n132:
# 1) This is Jay's Patch for Libfuzzer
# 2) Append other patches to this file
# 3) This file is applied before libfuzzer building during compiling stage
# =====================
diff --git a/compiler-rt/lib/fuzzer/FuzzerInternal.h b/compiler-rt/lib/fuzzer/FuzzerInternal.h
index a50a4e72b..fe00df6de 100644
--- a/compiler-rt/lib/fuzzer/FuzzerInternal.h
+++ b/compiler-rt/lib/fuzzer/FuzzerInternal.h
@@ -104,6 +104,7 @@ private:
   void ReportNewCoverage(InputInfo *II, const Unit &U);
   void PrintPulseAndReportSlowInput(const uint8_t *Data, size_t Size);
   void WriteUnitToFileWithPrefix(const Unit &U, const char *Prefix);
+  void NewWriteUnitToFileWithPrefix(const Unit &U, const char *Prefix);
   void PrintStats(const char *Where, const char *End = "\n", size_t Units = 0,
                   size_t Features = 0);
   void PrintStatusForNewUnit(const Unit &U, const char *Text);
diff --git a/compiler-rt/lib/fuzzer/FuzzerLoop.cpp b/compiler-rt/lib/fuzzer/FuzzerLoop.cpp
index d5fd0cb46..ec8f3e082 100644
--- a/compiler-rt/lib/fuzzer/FuzzerLoop.cpp
+++ b/compiler-rt/lib/fuzzer/FuzzerLoop.cpp
@@ -182,12 +182,15 @@ void Fuzzer::DumpCurrentUnit(const char *Prefix) {
     PrintHexArray(CurrentUnitData, UnitSize, "\n");
     PrintASCII(CurrentUnitData, UnitSize, "\n");
   }
-  WriteUnitToFileWithPrefix({CurrentUnitData, CurrentUnitData + UnitSize},
+  // WriteUnitToFileWithPrefix({CurrentUnitData, CurrentUnitData + UnitSize},
+  //                           Prefix);
+  NewWriteUnitToFileWithPrefix({CurrentUnitData, CurrentUnitData + UnitSize},
                             Prefix);
 }
 
 NO_SANITIZE_MEMORY
 void Fuzzer::DeathCallback() {
+  Printf("==== ERROR: libFuzzer: death callback triggered\n");
   DumpCurrentUnit("crash-");
   PrintFinalStats();
 }
@@ -632,6 +635,25 @@ void Fuzzer::WriteUnitToFileWithPrefix(const Unit &U, const char *Prefix) {
     Printf("Base64: %s\n", Base64(U).c_str());
 }
 
+void Fuzzer::NewWriteUnitToFileWithPrefix(const Unit &U, const char *Prefix) {
+  if (!Options.SaveArtifacts)
+    return;
+  size_t Size = U.size();
+  UniqFeatureSetTmp.clear();
+  TPC.CollectFeatures([&](uint32_t Feature) {
+    if (Corpus.AddFeature(Feature, static_cast<uint32_t>(Size), Options.Shrink))
+      UniqFeatureSetTmp.push_back(Feature);
+  });
+  std::string Path = Options.ArtifactPrefix + Prefix + Hash(UniqFeatureSetTmp);
+  if (!Options.ExactArtifactPath.empty())
+    Path = Options.ExactArtifactPath; // Overrides ArtifactPrefix.
+  WriteToFile(U, Path);
+  Printf("artifact_prefix='%s'; Test unit written to %s\n",
+         Options.ArtifactPrefix.c_str(), Path.c_str());
+  if (U.size() <= kMaxUnitSizeToPrint)
+    Printf("Base64: %s\n", Base64(U).c_str());
+}
+
 void Fuzzer::PrintStatusForNewUnit(const Unit &U, const char *Text) {
   if (!Options.PrintNEW)
     return;
diff --git a/compiler-rt/lib/fuzzer/FuzzerSHA1.cpp b/compiler-rt/lib/fuzzer/FuzzerSHA1.cpp
index b05655c8e..72720f113 100644
--- a/compiler-rt/lib/fuzzer/FuzzerSHA1.cpp
+++ b/compiler-rt/lib/fuzzer/FuzzerSHA1.cpp
@@ -221,4 +221,20 @@ std::string Hash(const Unit &U) {
   return Sha1ToString(Hash);
 }
 
+
+std::string Hash(std::vector<uint32_t> UniqFeatureSet) {
+	std::vector<unsigned char> buffer;
+	buffer.reserve(UniqFeatureSet.size() * sizeof(uint32_t));
+	for (uint32_t Feature : UniqFeatureSet) {
+		buffer.push_back(static_cast<unsigned char>(Feature >> 24));
+		buffer.push_back(static_cast<unsigned char>(Feature >> 16));
+		buffer.push_back(static_cast<unsigned char>(Feature >> 8));
+		buffer.push_back(static_cast<unsigned char>(Feature));
+	}
+
+	uint8_t Hash[kSHA1NumBytes];
+	ComputeSHA1(buffer.data(), buffer.size(), Hash);
+	return Sha1ToString(Hash);
+}
+
 }
diff --git a/compiler-rt/lib/fuzzer/FuzzerSHA1.h b/compiler-rt/lib/fuzzer/FuzzerSHA1.h
index 05cbacda8..d02c15fa1 100644
--- a/compiler-rt/lib/fuzzer/FuzzerSHA1.h
+++ b/compiler-rt/lib/fuzzer/FuzzerSHA1.h
@@ -27,6 +27,8 @@ std::string Sha1ToString(const uint8_t Sha1[kSHA1NumBytes]);
 
 std::string Hash(const Unit &U);
 
+std::string Hash(std::vector<uint32_t> UniqFeatureSet);
+
 }  // namespace fuzzer
 
 #endif  // LLVM_FUZZER_SHA1_H



