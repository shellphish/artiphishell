from .types import TypeIndex, Target, Syscall, Type, Flag, Resource, Const, construct_type
from .utils import bool_as_go
import json

class Syscalls:
    def __init__(self, syscalls: list[Syscall]):
        self._syscalls: list[Syscall] = syscalls

    def __getitem__(self, item):
        if isinstance(item, int):
            return self._syscalls[item]
        return next(filter(lambda s: s.name == item, self._syscalls))

    def __iter__(self):
        return iter(self._syscalls)

    def add(self, syscall: Syscall):
        self._syscalls += [syscall]

class Resources:
    def __init__(self, resources: list[Resource]):
        self._resources: list[Resource] = resources

    def __getitem__(self, item):
        if isinstance(item, int):
            return self._resources[item]
        return next(filter(lambda r: r.name == item, self._resources))

    def __iter__(self):
        return iter(self._resources)

class Types:
    def __init__(self, types: list[Type]):
        self._types: list[Type] = types

    def __getitem__(self, item):
        if isinstance(item, int):
            return self._types[item]
        return next(filter(lambda t: t.name == item, self._types))

    def __iter__(self):
        return iter(self._types)

    def add(self, typ: Type):
        tidx = len(self._types)
        typ.id = TypeIndex(tidx)
        self._types += [typ]

class Syzlang:
    def __init__(
        self,
        target: Target,
        resources: list[Resource],
        types: list[Type],
        syscalls: list[Syscall],
        flags: list[Flag],
        consts: list[Const]
    ):
        self._target: Target = target
        self.resources: Resources = Resources(resources)
        self.types: Types = Types(types)
        self.syscalls: Syscalls = Syscalls(syscalls)
        self.flags: list[Flag] = flags
        self.consts: list[Const] = consts

    @staticmethod
    def from_json(path):
        with open(path) as fp:
            syzlang_json = json.load(fp)

        target = Target(syzlang_json['Target'])

        resources = list()
        for idx, resource_obj in enumerate(syzlang_json['Resources']):
            resources += [Resource.from_json(resource_obj)]

        types = list()
        for type_id, type_obj in enumerate(syzlang_json['Types']):
            types += [construct_type(syzlang_json, type_id)]

        syscalls = list()
        for syscall in syzlang_json['Syscalls']:
            syscalls += [Syscall.from_json(syscall)]

        flags = list()
        for flag in syzlang_json['Flags']:
            flags += [Flag(flag['Name'], flag['Values'])]

        consts = list()
        for name, value in syzlang_json['Consts'].items():
            consts += [Const(name, value)]

        return Syzlang(target, resources, types, syscalls, flags, consts)

    def generate_rust(self, proj_src_path: str):

        resources_path = "/grammar/resources/gen.rs"
        resource_gen = ""
        resource_gen += "#![allow(non_upper_case_globals)]\n"
        resource_gen += "// THIS FILE IS AUTOGENERATED BY SYZLANG-BRIDGE\n"
        resource_gen += "use crate::grammar::resources::ResourceDesc;\n\n"

        for idx, resource_obj in enumerate(self.resources):
            resource_gen += resource_obj.as_rust(idx)

        with open(proj_src_path+resources_path, "w") as fp:
            fp.write(resource_gen)

        types_path = "/grammar/types/gen.rs"
        types_gen = ""
        types_gen += "#![allow(non_upper_case_globals)]\n"
        types_gen += "#![allow(dead_code)]\n"
        types_gen += "// THIS FILE IS AUTOGENERATED BY SYZLANG-BRIDGE\n"
        types_gen += "use crate::grammar::resources;\n"
        types_gen += "use crate::grammar::types::*;\n\n"

        for type_id, type_obj in enumerate(self.types):
            type_enum = type_obj.type_name[:-4] # Strip 'Type' from the end
            types_gen += (
                f"pub const type_{type_id}: {type_enum} = {type_enum} {{\n" # }}
                f"{type_obj.as_rust(self.types._types)}"
                f"}};\n\n"
            )

        type_table = "pub const TYPE_TABLE: &'static [Type] = &[\n" # ]
        for type_id, type_obj in enumerate(self.types):
            type_enum = type_obj.type_name[:-4] # Strip 'Type' from the end
            type_table += f"\tType::{type_enum}(type_{type_id}),\n"
        type_table += "];\n"


        with open(proj_src_path+types_path, "w") as fp:
            fp.write(types_gen+type_table)

        syscalls_path = "/grammar/syscalls/gen.rs"
        syscalls_gen = ""
        syscalls_gen += "use crate::grammar::syscalls::SyscallDef;\n"
        syscalls_gen += "use crate::grammar::syscalls::types;\n\n"
        syscalls_gen += "// THIS FILE IS AUTOGENERATED BY SYZLANG-BRIDGE\n"
        syscalls_gen += "pub const SYSCALL_TABLE: &'static [SyscallDef] = &[\n" #]
        for syscall in self.syscalls:
            #if name.startswith('syz_harness'):
            syscalls_gen += '\t' + syscall.as_rust(self.types._types)
        syscalls_gen += '];\n'

        with open(proj_src_path+syscalls_path, "w") as fp:
            fp.write(syscalls_gen)

    def generate_go(self, out_path: str):
        target = self._target

        tag = "syz_target,syz_os_%s,syz_arch_%s" % (target.os, target.arch)
        if target.vm_arch != "":
            tag += " syz_target,syz_os_%s,syz_arch_%s" % (target.os, target.vmarch)

        out = ""
        out += "// AUTOGENERATED FILE\n"
        out += "// +build !codeanalysis\n"
        out += "// +build !syz_target %s\n\n" % tag
        out += "package gen\n\n"
        out += "import . \"github.com/google/syzkaller/prog\"\n"
        out += "import . \"github.com/google/syzkaller/sys/%s\"\n\n" % target.os

        out += "func init() {\n"
        out += ("\tRegisterTarget(&Target{"+ \
            "OS: \"%s\", Arch: \"%s\", Revision: revision_%s, PtrSize: %d, PageSize: %d, "+ \
            "NumPages: %d, DataOffset: %d, LittleEndian: %s, ExecutorUsesShmem: %s, "+ \
            "Syscalls: syscalls_%s, Resources: resources_%s, Consts: consts_%s,"+ \
            "Flags: flags_%s}, types_%s, InitTarget)\n}\n\n") % (
                target.os, target.arch, target.arch, target.ptr_size, target.page_size,
                target.num_pages, target.data_offset, bool_as_go(target.little_endian), bool_as_go(target.executor_uses_shmem),
                target.arch, target.arch, target.arch, target.arch, target.arch
            )

        out += "var resources_%s = []*ResourceDesc{\n" % target.arch # }
        for resource in self.resources:
            out += resource.as_go() + ",\n"
        out += "}\n\n"

        out += "var syscalls_%s = []*Syscall{\n" % target.arch # }
        for syscall in self.syscalls:
            out += syscall.as_go() + ",\n"
        out += "}\n\n"

        out += "var types_%s = []Type{\n" % target.arch # }
        for typ in self.types:
            out += typ.as_go() + ",\n"
        out += "}\n\n"

        out += "var flags_%s = []FlagDesc{\n" % target.arch # }
        for flag in self.flags:
            out += flag.as_go() + ",\n"
        out += "}\n\n"

        out += "var consts_%s = []ConstValue{\n" % target.arch # }
        for const in self.consts:
            out += const.as_go() + ",\n"
        out += "}\n\n"

        revision = "A"*40
        out += "const revision_%s = \"%s\"\n" % (target.arch, revision)

        with open(out_path, "w+") as fp:
            fp.write(out)
